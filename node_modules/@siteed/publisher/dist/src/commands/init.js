"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initCommand = void 0;
const commander_1 = require("commander");
const init_1 = require("../core/init");
const workspace_1 = require("../core/workspace");
const logger_1 = require("../utils/logger");
exports.initCommand = new commander_1.Command()
    .name("init")
    .description("Initialize release configuration. When run from within a package directory, defaults to the current package. " +
    "In monorepo root, requires package names or initializes all packages.")
    .argument("[packages...]", "Package names to initialize (optional when in package directory)")
    .option("-f, --force", "Overwrite existing configuration")
    .option("-i, --interactive", "Run in interactive mode")
    .option("--format <format>", "Format of generated config files (json or typescript)", "json")
    .action(async (packages, commandOptions) => {
    const logger = new logger_1.Logger();
    try {
        const initService = new init_1.InitService(logger);
        const workspaceService = new workspace_1.WorkspaceService();
        // If no packages specified, try to get current package
        if (!packages || packages.length === 0) {
            const currentPackage = await workspaceService.getCurrentPackage();
            if (currentPackage) {
                packages = [currentPackage.name];
            }
        }
        const options = {
            force: commandOptions.force,
            interactive: commandOptions.interactive,
            format: commandOptions.format,
        };
        await initService.initialize({ packages, options });
    }
    catch (error) {
        logger.error("Initialization failed:", error instanceof Error ? error.message : String(error));
        process.exit(1);
    }
});
