"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YarnService = void 0;
const execa_1 = __importDefault(require("execa"));
const logger_1 = require("../utils/logger");
class YarnService {
    config;
    yarnVersion = null;
    logger;
    constructor(config, logger) {
        this.config = config;
        this.logger = logger ?? new logger_1.Logger();
    }
    async getYarnVersion() {
        if (this.yarnVersion)
            return this.yarnVersion;
        try {
            const result = await (0, execa_1.default)("yarn", ["--version"]);
            const version = result.stdout.trim();
            // Parse version string (e.g., "4.5.0" -> major: 4)
            const major = parseInt(version.split(".")[0], 10);
            // Consider anything >= 2.0.0 as Yarn Berry
            this.yarnVersion = {
                major: major >= 2 ? 2 : 1, // Normalize to either 1 or 2 for simpler checks
                full: version,
            };
            this.logger.debug("Detected Yarn version:", this.yarnVersion);
            return this.yarnVersion;
        }
        catch (error) {
            throw new Error("Failed to determine Yarn version");
        }
    }
    async execYarnCommand(args) {
        const version = await this.getYarnVersion();
        // Convert commands for Yarn 1
        if (version.major === 1) {
            // Map modern Yarn commands to Yarn 1 equivalents
            const yarn1Args = args.map((arg) => {
                if (arg === "npm whoami")
                    return "whoami";
                if (arg === "npm publish")
                    return "publish";
                if (arg === "npm info")
                    return "info";
                return arg;
            });
            return (0, execa_1.default)("yarn", yarn1Args);
        }
        // Use modern Yarn commands (Yarn Berry)
        return (0, execa_1.default)("yarn", args);
    }
    async validateAuth(config) {
        const effectiveConfig = this.getEffectiveConfig(config);
        this.logger.debug("Starting npm authentication validation", {
            registry: effectiveConfig.registry,
        });
        try {
            const version = await this.getYarnVersion();
            this.logger.debug("Configuring auth command for Yarn version:", version);
            // Check if authentication is configured in .yarnrc.yml for Yarn Berry
            if (version.major === 2) {
                try {
                    await this.execYarnCommand(["config", "get", "npmAuthToken"]);
                }
                catch (error) {
                    throw new Error("No authentication configured for Yarn Berry. Please add npmAuthToken to your .yarnrc.yml file:\n" +
                        "npmAuthToken: ${NPM_AUTH_TOKEN}\n" +
                        "Or run: yarn config set npmAuthToken <your-token>");
                }
            }
            // Try whoami command
            const args = version.major === 1
                ? ["whoami", "--registry", effectiveConfig.registry]
                : ["npm", "whoami"];
            this.logger.debug("Executing auth validation command:", {
                command: `yarn ${args.join(" ")}`,
                cwd: process.cwd(),
            });
            const result = await this.execYarnCommand(args);
            const username = result.stdout.toString().trim();
            if (!username) {
                throw new Error("Not authenticated to npm registry");
            }
            this.logger.debug("Authentication successful", { username });
        }
        catch (error) {
            this.logger.error("Authentication validation failed:", {
                error: error instanceof Error ? error.message : "Unknown error",
                registry: effectiveConfig.registry,
            });
            throw error;
        }
    }
    async publish(context, config) {
        const effectiveConfig = this.getEffectiveConfig(config);
        const version = await this.getYarnVersion();
        this.logger.debug("Starting package publication process", {
            package: context.name,
            version: context.currentVersion,
            registry: effectiveConfig.registry,
            yarnVersion: version,
        });
        try {
            const publishArgs = this.getPublishArgs(version, effectiveConfig);
            this.logger.debug("Attempting Yarn publish with args:", {
                command: `yarn ${publishArgs.join(" ")}`,
                cwd: context.path,
            });
            await this.execYarnCommand(publishArgs);
            this.logger.debug("Package published successfully with Yarn");
        }
        catch (error) {
            this.logger.warn("Yarn publish failed, attempting npm fallback", {
                error: error instanceof Error ? error.message : "Unknown error",
            });
            const npmArgs = this.getNpmPublishArgs(effectiveConfig);
            this.logger.debug("Attempting npm publish with args:", {
                command: `npm ${npmArgs.join(" ")}`,
                cwd: context.path,
            });
            try {
                await (0, execa_1.default)("npm", npmArgs, { cwd: context.path });
                this.logger.debug("Package published successfully with npm fallback");
            }
            catch (npmError) {
                this.logger.error("Publication failed with both Yarn and npm", {
                    error: npmError instanceof Error ? npmError.message : "Unknown error",
                });
                throw npmError;
            }
        }
        const result = {
            published: true,
            registry: effectiveConfig.registry,
        };
        this.logger.debug("Publication completed successfully", result);
        return result;
    }
    getPublishArgs(version, config) {
        return version.major === 1
            ? [
                "publish",
                "--registry",
                config.registry,
                "--tag",
                config.tag,
                "--access",
                config.access,
            ]
            : ["npm", "publish", "--tag", config.tag, "--access", config.access];
    }
    getNpmPublishArgs(config) {
        const args = [
            "publish",
            "--registry",
            config.registry,
            "--tag",
            config.tag,
            "--access",
            config.access,
        ];
        if (config.otp) {
            args.push("--otp", config.otp);
        }
        return args;
    }
    async getLatestVersion(packageName, config) {
        const effectiveConfig = this.getEffectiveConfig(config);
        try {
            const version = await this.getYarnVersion();
            let result;
            if (version.major === 1) {
                result = await (0, execa_1.default)("yarn", [
                    "info",
                    packageName,
                    "version",
                    "--registry",
                    effectiveConfig.registry,
                    "--json",
                ]);
                const parsed = this.parseJsonResponse(result.stdout);
                return parsed.data ?? "0.0.0";
            }
            else {
                // For Yarn Berry (2+), use npm view command
                result = await (0, execa_1.default)("npm", [
                    "view",
                    packageName,
                    "version",
                    "--registry",
                    effectiveConfig.registry,
                    "--json",
                ]);
                // npm view returns the version directly when using --json
                const version = result.stdout.trim().replace(/^"|"$/g, "");
                return version || "0.0.0";
            }
        }
        catch (error) {
            this.logger.warn("Failed to get latest version", {
                error: error instanceof Error ? error.message : "Unknown error",
            });
            return "0.0.0";
        }
    }
    async checkWorkspaceIntegrity() {
        try {
            this.logger.debug("Checking Yarn workspace integrity...");
            const startTime = performance.now();
            const version = await this.getYarnVersion();
            // Use different commands based on Yarn version
            if (version.major === 1) {
                await (0, execa_1.default)("yarn", ["install", "--frozen-lockfile", "--check-files"]);
            }
            else {
                // Yarn Berry uses different flags
                await (0, execa_1.default)("yarn", ["install", "--immutable"]);
            }
            const duration = ((performance.now() - startTime) / 1000).toFixed(2);
            this.logger.debug(`Yarn integrity check completed in ${duration}s`);
            return true;
        }
        catch (error) {
            this.logger.debug("Yarn integrity check failed", {
                error: error instanceof Error ? error.message : "Unknown error",
            });
            return false;
        }
    }
    async getWorkspaceVersion(packageName) {
        try {
            const result = await (0, execa_1.default)("yarn", [
                "workspaces",
                "info",
                packageName,
                "--json",
            ]);
            const parsed = this.parseJsonResponse(result.stdout);
            return parsed.version ?? "0.0.0";
        }
        catch {
            return "0.0.0";
        }
    }
    async updateDependencies(context, dependencies) {
        const version = await this.getYarnVersion();
        if (version.major >= 2) {
            // Use new strategy for Yarn 2+
            await this.updateDependenciesWithStrategy(context, dependencies);
        }
        else {
            // Fallback for Yarn 1.x
            try {
                await (0, execa_1.default)("yarn", ["add", ...dependencies], {
                    cwd: context.path,
                });
            }
            catch (error) {
                if (error instanceof Error) {
                    throw new Error(`Failed to update dependencies: ${error.message}`);
                }
                throw new Error("Failed to update dependencies: Unknown error occurred");
            }
        }
    }
    async updateDependenciesWithStrategy(context, dependencies) {
        try {
            // For each dependency, first try to resolve if it's a workspace package
            for (const dep of dependencies) {
                const args = ["up"];
                // If it's a workspace dependency, force latest version
                if (dep.startsWith("@siteed/")) {
                    args.push("--mode=update-lockfile");
                }
                args.push(dep);
                await (0, execa_1.default)("yarn", args, {
                    cwd: context.path,
                });
            }
        }
        catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to update dependencies: ${error.message}`);
            }
            throw new Error("Failed to update dependencies: Unknown error occurred");
        }
    }
    async pack(context) {
        let packageFile = "";
        try {
            const fs = await Promise.resolve().then(() => __importStar(require("fs/promises")));
            const path = await Promise.resolve().then(() => __importStar(require("path")));
            const tar = await Promise.resolve().then(() => __importStar(require("tar")));
            const crypto = await Promise.resolve().then(() => __importStar(require("crypto")));
            this.logger.debug("Starting package pack process", {
                package: context.name,
                path: context.path,
            });
            const result = await this.execYarnCommand(["pack", "--json"]);
            const parsed = this.parseJsonResponse(result.stdout);
            packageFile = parsed.filename || "";
            if (!packageFile) {
                throw new Error("No package file was created during pack");
            }
            const packagePath = path.join(context.path, packageFile);
            this.logger.debug("Package created", {
                filename: packageFile,
                path: packagePath,
            });
            // Get compressed size
            const stats = await fs.stat(packagePath);
            // Calculate SHA hash
            const fileBuffer = await fs.readFile(packagePath);
            const hashSum = crypto.createHash("sha256");
            hashSum.update(fileBuffer);
            const sha = hashSum.digest("hex");
            // Get uncompressed size and file list
            const files = [];
            let uncompressedSize = 0;
            await tar.list({
                file: packagePath,
                onentry: (entry) => {
                    if (entry.type === "File") {
                        files.push({
                            path: entry.path,
                            size: entry.size,
                        });
                        uncompressedSize += entry.size;
                    }
                },
            });
            const archiveInfo = {
                filename: packageFile,
                path: packagePath,
                size: {
                    compressed: stats.size,
                    uncompressed: uncompressedSize,
                },
                files,
                created: new Date(),
                sha,
            };
            this.logger.debug("Package analysis complete", {
                compressedSize: `${(stats.size / 1024).toFixed(2)}KB`,
                uncompressedSize: `${(uncompressedSize / 1024).toFixed(2)}KB`,
                fileCount: files.length,
            });
            return archiveInfo;
        }
        catch (error) {
            this.logger.error("Package pack failed", {
                error: error instanceof Error ? error.message : "Unknown error",
                package: context.name,
            });
            throw error;
        }
        finally {
            if (packageFile) {
                try {
                    const fs = await Promise.resolve().then(() => __importStar(require("fs/promises")));
                    const path = await Promise.resolve().then(() => __importStar(require("path")));
                    const filePath = path.join(context.path, packageFile);
                    await fs.unlink(filePath);
                    this.logger.debug("Cleaned up package file", { path: filePath });
                }
                catch (cleanupError) {
                    this.logger.warn("Failed to cleanup package file", {
                        error: cleanupError instanceof Error
                            ? cleanupError.message
                            : "Unknown error",
                        path: packageFile,
                    });
                }
            }
        }
    }
    async runScript(context, script) {
        try {
            await (0, execa_1.default)("yarn", ["run", script], {
                cwd: context.path,
            });
        }
        catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to run script ${script}: ${error.message}`);
            }
            throw new Error(`Failed to run script ${script}: Unknown error occurred`);
        }
    }
    async install() {
        try {
            await (0, execa_1.default)("yarn", ["install"]);
        }
        catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to install dependencies: ${error.message}`);
            }
            throw new Error("Failed to install dependencies: Unknown error occurred");
        }
    }
    getEffectiveConfig(providedConfig) {
        return providedConfig?.npm ?? this.config;
    }
    parseJsonResponse(stdout) {
        try {
            return JSON.parse(stdout);
        }
        catch {
            return {};
        }
    }
    async getDependencyUpdates() {
        try {
            const version = await this.getYarnVersion();
            const updates = [];
            let result;
            if (version.major === 1) {
                result = await (0, execa_1.default)("yarn", ["outdated", "--json"]);
            }
            else {
                result = await (0, execa_1.default)("yarn", ["upgrade-interactive", "--json"]);
            }
            const outdated = this.parseJsonResponse(result.stdout);
            for (const dep of outdated) {
                updates.push({
                    name: dep.name,
                    currentVersion: dep.current,
                    latestVersion: dep.latest,
                    type: dep.type,
                    isWorkspaceDependency: dep.workspace,
                    updateAvailable: dep.current !== dep.latest,
                });
            }
            return updates;
        }
        catch (error) {
            this.logger.debug("Failed to check for dependency updates", {
                error: error instanceof Error ? error.message : "Unknown error",
            });
            return [];
        }
    }
}
exports.YarnService = YarnService;
