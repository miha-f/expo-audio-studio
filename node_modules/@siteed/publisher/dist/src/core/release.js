"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReleaseService = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("../utils");
const prompt_1 = require("../utils/prompt");
const changelog_1 = require("./changelog");
const git_1 = require("./git");
const integrity_1 = require("./integrity");
const package_manager_1 = require("./package-manager");
const version_1 = require("./version");
const workspace_1 = require("./workspace");
class ReleaseService {
    config;
    logger;
    git;
    packageManager;
    version;
    changelog;
    workspace;
    prompts;
    integrityService;
    rootDir;
    constructor(config, logger) {
        this.config = config;
        this.logger = logger;
        if (!["npm", "yarn"].includes(config.packageManager)) {
            logger.warning('Invalid package manager specified, defaulting to "yarn"');
            this.config.packageManager = "yarn";
        }
        this.rootDir = (0, utils_1.findMonorepoRootSync)(process.cwd());
        this.git = new git_1.GitService(config.git, this.rootDir, this.logger);
        this.packageManager = package_manager_1.PackageManagerFactory.create(config.packageManager, config.npm);
        this.version = new version_1.VersionService(config.git);
        this.changelog = new changelog_1.ChangelogService(this.logger);
        this.workspace = new workspace_1.WorkspaceService(config, this.logger);
        this.prompts = new prompt_1.Prompts(this.logger);
        this.integrityService = new integrity_1.WorkspaceIntegrityService(this.packageManager, this.logger);
    }
    async releasePackages(packageNames, options) {
        this.logger.info("Starting release process...");
        if (options.checkIntegrity) {
            const integrityCheck = await this.integrityService.check();
            if (!integrityCheck) {
                throw new Error("Workspace integrity check failed. Please fix the issues above or run without --check-integrity");
            }
        }
        if (packageNames.length === 0) {
            const currentPackage = await this.workspace.getCurrentPackage();
            if (currentPackage) {
                packageNames = [currentPackage.name];
            }
        }
        this.logger.info(`Finding packages matching: ${packageNames.join(", ")}...`);
        const packages = await this.workspace.getPackages(packageNames);
        if (packages.length === 0) {
            this.logger.warning("No matching packages found");
            return [];
        }
        const results = [];
        for (const pkg of packages) {
            this.logger.info(`\nProcessing package ${pkg.name}...`);
            const result = await this.releasePackage(pkg, {
                ...options,
                publish: options.npmPublish,
            });
            results.push(result);
        }
        return results;
    }
    async releaseAll(options) {
        const changedPackages = await this.workspace.getChangedPackages();
        return this.releasePackages(changedPackages.map((p) => p.name), options);
    }
    async releasePackage(context, options) {
        let tempFiles = [];
        let previousCommitHash = null;
        let tagCreated = false;
        try {
            this.logger.info(`Loading package configuration...`);
            const packageConfig = await this.getEffectiveConfig(context.name);
            const changelogPath = path_1.default.join(context.path, packageConfig.changelogFile || "CHANGELOG.md");
            this.logger.debug(`Package path: ${context.path}`);
            this.logger.debug(`Changelog path: ${changelogPath}`);
            this.logger.info("Validating environment...");
            await this.validateEnvironment({
                skipGitCheck: options.skipGitCheck,
                skipUpstreamTracking: options.skipUpstreamTracking,
                checkIntegrity: options.checkIntegrity,
                allowBranch: options.allowBranch,
            });
            this.logger.info("Determining new version...");
            context.newVersion = await this.determineVersion(context, packageConfig);
            previousCommitHash = await this.git.getCurrentCommitHash();
            this.logger.info("Preparing changelog entry...");
            const changelogEntry = await this.prepareChangelogEntry(context, packageConfig);
            if (!options.dryRun && !(await this.prompts.confirmRelease())) {
                throw new Error("Release cancelled");
            }
            if (options.dryRun) {
                this.logger.info("Generating dry run report...");
                const newVersion = context.newVersion ||
                    (await this.determineVersion(context, packageConfig));
                const dryRunReport = await this.createDryRunReport(context, packageConfig, {
                    dryRun: true,
                    ...options,
                    newVersion,
                });
                return dryRunReport;
            }
            tempFiles = await this.backupFiles(context, packageConfig);
            await this.runHooks("preRelease", packageConfig, context);
            await this.updateVersion(context, packageConfig);
            await this.updateDependencies(context, packageConfig);
            if (changelogEntry) {
                await this.changelog.update(context, changelogEntry, packageConfig);
            }
            await this.git.createTag(context, options.force);
            tagCreated = true;
            await this.git.commitChanges(context, changelogPath);
            if (options.gitPush && this.config.git?.push !== false) {
                await this.git.push(options.force);
            }
            if (options.publish && this.config.npm?.publish !== false) {
                await this.packageManager.publish(context, { npm: this.config.npm });
            }
            return {
                changelog: changelogEntry ?? "",
                git: {
                    tag: context.newVersion,
                    commit: previousCommitHash,
                },
                packageName: context.name,
                version: context.newVersion,
            };
        }
        catch (error) {
            this.logger.error(`Release process failed: ${error instanceof Error ? error.message : String(error)}`);
            this.logger.info("Rolling back changes...");
            if (previousCommitHash) {
                await this.git.resetToCommit(previousCommitHash);
            }
            if (tagCreated && context.newVersion) {
                const tagName = `${context.name}@${context.newVersion}`;
                await this.git.deleteTag(tagName, true);
            }
            for (const file of tempFiles) {
                await promises_1.default.writeFile(file.path, file.content, "utf-8");
            }
            throw error;
        }
    }
    async validateEnvironment(options) {
        const context = await this.workspace.getCurrentPackage();
        if (!context) {
            throw new Error("No package found in current directory");
        }
        await this.validateWithProgress(context, options);
    }
    async determineVersion(context, config) {
        if (config.bumpStrategy === "conventional") {
            const analyzedBumpType = await this.version.analyzeCommits(context);
            const bumpType = config.bumpType ?? analyzedBumpType;
            return this.version.determineVersion(context, bumpType, config.preReleaseId);
        }
        if (config.bumpStrategy === "prompt") {
            const bumpType = await this.prompts.getVersionBump(context, this.version);
            return this.version.determineVersion(context, bumpType, config.preReleaseId);
        }
        return this.version.determineVersion(context, "patch", config.preReleaseId);
    }
    async updateDependencies(context, config) {
        if (!config.updateDependenciesOnRelease) {
            return;
        }
        const workspaceDependencies = this.getWorkspaceDependencies(context);
        if (workspaceDependencies.length === 0) {
            return;
        }
        const updates = await this.analyzeDependencyUpdates(context, workspaceDependencies);
        if (updates.length === 0) {
            return;
        }
        let shouldUpdate = false;
        switch (config.dependencyUpdateStrategy) {
            case "auto":
                shouldUpdate = true;
                break;
            case "prompt":
                shouldUpdate = await this.prompts.confirmDependencyUpdates(context.name, updates);
                break;
            case "none":
            default:
                shouldUpdate = false;
                break;
        }
        if (shouldUpdate) {
            await this.packageManager.updateDependencies(context, workspaceDependencies);
        }
    }
    getWorkspaceDependencies(context) {
        const allDependencies = {
            ...context.dependencies,
            ...context.devDependencies,
            ...context.peerDependencies,
        };
        return Object.keys(allDependencies).filter((dep) => dep.startsWith("@siteed/") || // Adjust this prefix based on your workspace
            dep.startsWith("@your-scope/"));
    }
    async runHooks(hookName, config, context) {
        const hook = config.hooks[hookName];
        if (hook) {
            this.logger.info(`Running ${hookName} hook...`);
            await hook(context);
        }
    }
    async getEffectiveConfig(packageName) {
        const packageConfig = await this.workspace.getPackageConfig(packageName);
        const packagePattern = Object.keys(this.config.packages).find((pattern) => this.matchPackagePattern(packageName, pattern));
        const patternConfig = packagePattern
            ? this.config.packages[packagePattern]
            : {};
        return {
            ...this.config,
            ...patternConfig,
            ...packageConfig,
            packageManager: this.config.packageManager,
        };
    }
    matchPackagePattern(packageName, pattern) {
        const regexPattern = pattern
            .replace(/\*/g, ".*")
            .replace(/\?/g, ".")
            .replace(/\//g, "\\/");
        return new RegExp(`^${regexPattern}$`).test(packageName);
    }
    async createDryRunReport(context, config, options) {
        const tagName = this.git.getTagName(context.name, options.newVersion);
        const currentCommit = await this.git.getCurrentCommitHash();
        // Generate the changelog content
        const changelogContent = options.changelog ??
            (await this.changelog.previewNewVersion(context, config, {
                newVersion: options.newVersion,
                conventionalCommits: config.conventionalCommits || false,
                format: config.changelogFormat || "conventional",
                includeEmptySections: config.changelogFormat === "keep-a-changelog",
            }));
        // Get dependency updates
        const dependencyUpdates = await this.analyzeDependencyUpdates(context, this.getWorkspaceDependencies(context));
        return {
            packageName: context.name,
            currentVersion: context.currentVersion,
            newVersion: options.newVersion,
            changelog: changelogContent,
            git: {
                tag: tagName,
                commit: currentCommit,
                willPush: config.git.push,
            },
            npm: {
                willPublish: config.npm.publish,
                registry: config.npm.registry,
                tag: config.npm.tag,
            },
            dependencies: dependencyUpdates,
        };
    }
    async analyzeChanges(packageNames) {
        const packages = await this.workspace.getPackages(packageNames);
        const changes = [];
        for (const pkg of packages) {
            const packageConfig = await this.getEffectiveConfig(pkg.name);
            const suggestedVersion = await this.determineSuggestedVersion(pkg, packageConfig);
            const gitChanges = await this.git.hasChanges(pkg.path);
            const changelogEntries = await this.changelog.getUnreleasedChanges(pkg, packageConfig);
            // Get workspace dependencies that need updates
            const workspaceDeps = this.getWorkspaceDependencies(pkg);
            const dependencyUpdates = await this.analyzeDependencyUpdates(pkg, workspaceDeps);
            changes.push({
                name: pkg.name,
                path: pkg.path,
                currentVersion: pkg.currentVersion,
                suggestedVersion,
                dependencies: dependencyUpdates,
                devDependencies: pkg.devDependencies ?? {},
                peerDependencies: pkg.peerDependencies ?? {},
                hasGitChanges: gitChanges,
                changelogEntries,
            });
        }
        return changes;
    }
    async determineSuggestedVersion(context, config) {
        if (config.bumpStrategy === "conventional") {
            const bumpType = config.bumpType ?? (await this.version.analyzeCommits(context));
            return this.version.determineVersion(context, bumpType, config.preReleaseId);
        }
        return this.version.determineVersion(context, "patch", config.preReleaseId);
    }
    async analyzeDependencyUpdates(context, dependencies) {
        const updates = [];
        for (const dep of dependencies) {
            let depType;
            let currentVersion;
            if (context.dependencies?.[dep]) {
                depType = "dependencies";
                currentVersion = context.dependencies[dep];
            }
            else if (context.devDependencies?.[dep]) {
                depType = "devDependencies";
                currentVersion = context.devDependencies[dep];
            }
            else if (context.peerDependencies?.[dep]) {
                depType = "peerDependencies";
                currentVersion = context.peerDependencies[dep];
            }
            if (currentVersion && depType) {
                const latestVersion = await this.packageManager.getLatestVersion(dep);
                if (latestVersion !== currentVersion) {
                    updates.push({
                        name: dep,
                        currentVersion,
                        newVersion: latestVersion,
                        type: depType,
                    });
                }
            }
        }
        return updates;
    }
    async getGitChanges(packageName) {
        const packages = await this.workspace.getPackages([packageName]);
        const pkg = packages[0];
        if (!pkg) {
            return [];
        }
        const lastTag = await this.git.getLastTag(packageName);
        return this.git.getCommitsSinceTag(lastTag, {
            packageName: pkg.name,
            packagePath: pkg.path,
            filterByPath: true,
        });
    }
    async previewChangelog(packageName) {
        const packages = await this.workspace.getPackages([packageName]);
        if (packages.length === 0) {
            throw new Error(`Package ${packageName} not found`);
        }
        const packageConfig = await this.getEffectiveConfig(packageName);
        return this.changelog.previewNewVersion(packages[0], packageConfig, {
            newVersion: packages[0].newVersion ?? "x.x.x",
            conventionalCommits: packageConfig.conventionalCommits || false,
            format: packageConfig.changelogFormat || "conventional",
            includeEmptySections: packageConfig.changelogFormat === "keep-a-changelog",
        });
    }
    /**
     * Prepares a changelog entry for a new version release.
     *
     * @param context - Package context containing version and path information
     * @param packageConfig - Release configuration for the package
     * @returns Promise<string | undefined> - The final changelog entry content, or undefined if skipped
     */
    async prepareChangelogEntry(context, packageConfig) {
        const changelogPath = path_1.default.join(context.path, packageConfig.changelogFile || "CHANGELOG.md");
        this.logger.debug(`Changelog path: ${changelogPath}`);
        try {
            // Check if changelog exists
            await promises_1.default.access(changelogPath);
            // Get unreleased changes from existing changelog
            this.logger.info("Reading unreleased changes from changelog...");
            const unreleasedChanges = await this.changelog.getUnreleasedChanges(context, packageConfig);
            // Get git changes since last release
            const gitChanges = await this.getGitChanges(context.name);
            this.logger.debug("Unreleased changes from changelog:", unreleasedChanges);
            this.logger.debug("Git changes since last release:", gitChanges);
            let finalChangelog;
            if (unreleasedChanges.length > 0) {
                // Handle existing unreleased changes
                this.logger.info(`Found ${unreleasedChanges.length} unreleased changes in changelog:`);
                this.logger.info(unreleasedChanges.join("\n"));
                const preview = await this.changelog.previewNewVersion(context, packageConfig, {
                    newVersion: context.newVersion ?? "x.x.x",
                    conventionalCommits: packageConfig.conventionalCommits || false,
                    format: packageConfig.changelogFormat || "conventional",
                    includeEmptySections: false,
                });
                this.logger.info("\nChangelog entry will look like this:\n");
                this.logger.info(preview);
                // Allow user to confirm or provide manual entry
                const confirmed = await this.prompts.confirmChangelogContent(preview);
                finalChangelog = confirmed
                    ? preview
                    : await this.prompts.getManualChangelogEntry();
            }
            else {
                // Generate changelog from git commits if no unreleased changes
                this.logger.info("No unreleased changes found, analyzing git commits...");
                const preview = await this.changelog.previewNewVersion(context, packageConfig, {
                    newVersion: context.newVersion ?? "x.x.x",
                    conventionalCommits: packageConfig.conventionalCommits || false,
                    format: packageConfig.changelogFormat || "conventional",
                    includeEmptySections: packageConfig.changelogFormat === "keep-a-changelog",
                });
                this.logger.info("\nProposed changelog entries:\n");
                this.logger.info(preview);
                // Allow user to confirm or provide manual entry
                const confirmed = await this.prompts.confirmChangelogContent(preview);
                finalChangelog = confirmed
                    ? preview
                    : await this.prompts.getManualChangelogEntry();
            }
            return finalChangelog;
        }
        catch (error) {
            this.logger.error("Error preparing changelog entry:", error);
            // Handle case where changelog doesn't exist
            const shouldCreate = await this.prompts.confirmChangelogCreation(context.name);
            if (shouldCreate) {
                return this.changelog.generate(context, packageConfig);
            }
            return undefined;
        }
    }
    async backupFiles(context, config) {
        const files = [
            path_1.default.join(context.path, "package.json"),
            path_1.default.join(context.path, config.changelogFile || "CHANGELOG.md"),
        ];
        const backups = [];
        for (const filePath of files) {
            try {
                const content = await promises_1.default.readFile(filePath, "utf-8");
                backups.push({ path: filePath, content });
            }
            catch (error) {
                // Ignore if file doesn't exist
            }
        }
        return backups;
    }
    async validateWithProgress(context, options) {
        const validations = [
            {
                name: "Git Status",
                skip: options.skipGitCheck,
                validate: async () => {
                    this.logger.info("Validating git status...");
                    await this.git.validateStatus({
                        skipUpstreamTracking: options.skipUpstreamTracking,
                        allowBranch: options.allowBranch,
                    });
                },
            },
            {
                name: "Package Manager",
                skip: false,
                validate: async () => {
                    if (this.config.npm?.publish) {
                        this.logger.info("Validating npm authentication...");
                        await this.packageManager.validateAuth(this.config);
                    }
                },
            },
            {
                name: "Dependencies",
                skip: !options.checkIntegrity,
                validate: async () => {
                    this.logger.info("Validating workspace dependencies...");
                    const result = await this.integrityService.checkWithDetails(true);
                    if (!result.isValid) {
                        const messages = result.issues
                            .map((issue) => `${issue.severity.toUpperCase()}: ${issue.message}`)
                            .join("\n");
                        throw new Error(`Dependency validation failed:\n${messages}`);
                    }
                },
            },
            {
                name: "Version",
                skip: false,
                validate: () => {
                    this.logger.info("Validating version format...");
                    this.version.validateVersion(context.currentVersion);
                    return Promise.resolve();
                },
            },
            {
                name: "Changelog",
                skip: false,
                validate: async () => {
                    this.logger.info("Validating changelog format...");
                    await this.changelog.validate(context, await this.getEffectiveConfig(context.name));
                },
            },
        ];
        let completedSteps = 0;
        const totalSteps = validations.filter((v) => !v.skip).length;
        for (const validation of validations) {
            if (validation.skip)
                continue;
            try {
                await this.withTimeout(validation.validate(), 30000, `${validation.name} validation`);
                completedSteps++;
                this.logger.success(`✓ ${validation.name} (${completedSteps}/${totalSteps})`);
            }
            catch (error) {
                this.logger.error(`✗ ${validation.name} validation failed:`);
                if (error instanceof Error) {
                    this.logger.error(error.message);
                }
                else {
                    this.logger.error(String(error));
                }
                throw error;
            }
        }
        this.logger.success("\nAll validations passed successfully!");
    }
    async withTimeout(promise, timeoutMs, operation) {
        let timeoutId;
        const timeoutPromise = new Promise((_, reject) => {
            timeoutId = setTimeout(() => {
                reject(new Error(`Operation "${operation}" timed out after ${timeoutMs}ms`));
            }, timeoutMs);
        });
        try {
            const result = await Promise.race([promise, timeoutPromise]);
            if (timeoutId)
                clearTimeout(timeoutId);
            return result;
        }
        catch (error) {
            if (timeoutId)
                clearTimeout(timeoutId);
            throw error;
        }
    }
    async updateVersion(context, config) {
        await this.version.bump(context, config);
    }
    async createDryRunPreview(pkg, options) {
        const context = {
            name: pkg.name,
            path: pkg.path,
            currentVersion: pkg.currentVersion,
            newVersion: pkg.suggestedVersion,
            dependencies: pkg.dependencies.reduce((acc, dep) => {
                if (dep.type === "dependencies") {
                    acc[dep.name] = dep.currentVersion;
                }
                return acc;
            }, {}),
            devDependencies: pkg.devDependencies,
            peerDependencies: pkg.peerDependencies,
        };
        const config = await this.getEffectiveConfig(pkg.name);
        return this.createDryRunReport(context, config, {
            ...options,
            newVersion: pkg.suggestedVersion,
            changelog: await this.changelog.previewNewVersion(context, config, {
                newVersion: pkg.suggestedVersion,
                conventionalCommits: config.conventionalCommits || false,
                format: config.changelogFormat || "conventional",
                includeEmptySections: config.changelogFormat === "keep-a-changelog",
            }),
        });
    }
}
exports.ReleaseService = ReleaseService;
