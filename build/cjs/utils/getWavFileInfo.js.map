{"version":3,"file":"getWavFileInfo.js","sourceRoot":"","sources":["../../../src/utils/getWavFileInfo.ts"],"names":[],"mappings":"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","sourcesContent":["// packages/expo-audio-stream/src/utils/getWavFileInfo.ts\n\nimport { BitDepth, SampleRate } from '../ExpoAudioStream.types'\nimport {\n    DATA_CHUNK_ID,\n    DEFAULT_BIT_DEPTH,\n    DEFAULT_SAMPLE_RATE,\n    FMT_CHUNK_ID,\n    INFO_CHUNK_ID,\n    RIFF_HEADER,\n    WAVE_HEADER,\n} from '../constants'\n\n// Audio format descriptions\nconst AUDIO_FORMATS: { [key: number]: string } = {\n    1: 'PCM',\n    3: 'IEEE float',\n    6: '8-bit ITU-T G.711 A-law',\n    7: '8-bit ITU-T G.711 Âµ-law',\n    65534: 'WAVE_FORMAT_EXTENSIBLE',\n}\n\n/**\n * Interface representing the metadata of a WAV file.\n */\nexport interface WavFileInfo {\n    sampleRate: SampleRate\n    numChannels: number\n    bitDepth: BitDepth\n    size: number // in bytes\n    durationMs: number // in ms\n    audioFormatDescription: string // Description of the audio format\n    byteRate: number // Average bytes per second\n    blockAlign: number // Number of bytes for one sample including all channels\n    creationDateTime?: string // Optional creation date and time\n    comments?: string // Optional comments or tags\n    compressionType?: string // Optional compression type\n    dataChunkOffset: number // Position of the first data chunk\n}\n\n/**\n * Extracts metadata from a WAV buffer.\n *\n * @param arrayBuffer - The array buffer containing the WAV data.\n * @returns A promise that resolves to the extracted metadata.\n */\nexport const getWavFileInfo = async (\n    arrayBuffer: ArrayBuffer\n): Promise<WavFileInfo> => {\n    const view = new DataView(arrayBuffer)\n\n    // Check if the file is a valid RIFF/WAVE file\n    const riffHeader = view.getUint32(0, false)\n    const waveHeader = view.getUint32(8, false)\n    if (riffHeader !== RIFF_HEADER || waveHeader !== WAVE_HEADER) {\n        throw new Error('Invalid WAV file')\n    }\n\n    // Initialize variables for the metadata\n    let fmtChunkOffset = 12\n    let sampleRate: SampleRate = DEFAULT_SAMPLE_RATE\n    let numChannels = 0\n    let bitDepth: BitDepth = DEFAULT_BIT_DEPTH\n    let dataChunkSize = 0\n    let audioFormat = 0\n    let byteRate = 0\n    let blockAlign = 0\n    let creationDateTime = ''\n    let comments = ''\n    let dataChunkOffset = 0\n\n    // Parse chunks to find the \"fmt \" and \"data\" chunks\n    while (fmtChunkOffset < view.byteLength) {\n        const chunkId = view.getUint32(fmtChunkOffset, false)\n        const chunkSize = view.getUint32(fmtChunkOffset + 4, true)\n        if (chunkId === FMT_CHUNK_ID) {\n            // \"fmt \"\n            audioFormat = view.getUint16(fmtChunkOffset + 8, true)\n            if (!AUDIO_FORMATS[audioFormat]) {\n                throw new Error('Unsupported WAV file format')\n            }\n            numChannels = view.getUint16(fmtChunkOffset + 10, true)\n            sampleRate = view.getUint32(fmtChunkOffset + 12, true) as SampleRate\n            byteRate = view.getUint32(fmtChunkOffset + 16, true)\n            blockAlign = view.getUint16(fmtChunkOffset + 20, true)\n            bitDepth = view.getUint16(fmtChunkOffset + 22, true) as BitDepth\n        } else if (chunkId === DATA_CHUNK_ID) {\n            // \"data\"\n            dataChunkSize = chunkSize\n            dataChunkOffset = fmtChunkOffset + 8 // Position after chunk header\n            break\n        } else if (chunkId === INFO_CHUNK_ID) {\n            // \"INFO\"\n            // Read INFO chunk (assuming it contains a text-based creation date/time and comments)\n            const infoStart = fmtChunkOffset + 8\n            const infoText = new TextDecoder().decode(\n                new Uint8Array(\n                    arrayBuffer.slice(infoStart, infoStart + chunkSize)\n                )\n            )\n            const infoParts = infoText.split('\\0')\n            creationDateTime = infoParts[0]\n            comments = infoParts[1]\n        }\n        fmtChunkOffset += 8 + chunkSize\n    }\n\n    if (!sampleRate || !numChannels || !bitDepth || !dataChunkSize) {\n        throw new Error('Incomplete WAV file information')\n    }\n\n    // Calculate duration\n    const bytesPerSample = bitDepth / 8\n    const numSamples = dataChunkSize / (numChannels * bytesPerSample)\n    const durationMs = (numSamples / sampleRate) * 1000\n\n    return {\n        sampleRate,\n        numChannels,\n        bitDepth,\n        size: arrayBuffer.byteLength,\n        durationMs,\n        audioFormatDescription: AUDIO_FORMATS[audioFormat],\n        byteRate,\n        blockAlign,\n        creationDateTime: creationDateTime || undefined,\n        comments: comments || undefined,\n        compressionType:\n            audioFormat === 1 ? 'None' : AUDIO_FORMATS[audioFormat],\n        dataChunkOffset,\n    }\n}\n"]}