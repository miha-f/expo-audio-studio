{"version":3,"file":"writeWavHeader.js","sourceRoot":"","sources":["../../../src/utils/writeWavHeader.ts"],"names":[],"mappings":"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","sourcesContent":["// packages/expo-audio-stream/src/utils/writeWavHeader.ts\n\n/**\n * Options for creating a WAV header.\n */\nexport interface WavHeaderOptions {\n    /** Optional buffer containing audio data. If provided, it will be combined with the header. */\n    buffer?: ArrayBuffer\n    /** The sample rate of the audio in Hz (e.g., 44100). */\n    sampleRate: number\n    /** The number of audio channels (e.g., 1 for mono, 2 for stereo). */\n    numChannels: number\n    /** The bit depth of the audio (e.g., 16, 24, or 32). */\n    bitDepth: number\n    /** Whether the audio data is in float format (only applies to 32-bit) */\n    isFloat?: boolean\n}\n\n/**\n * Writes or updates a WAV (RIFF) header based on the provided options.\n *\n * This function can be used in three ways:\n * 1. To create a standalone WAV header (when no buffer is provided).\n * 2. To create a WAV header and combine it with existing audio data (when a buffer without a header is provided).\n * 3. To update an existing WAV header in the provided buffer.\n *\n * For streaming audio where the final size is unknown, this function sets the size fields\n * to the maximum 32-bit value (0xFFFFFFFF). These can be updated later using the\n * `updateWavHeaderSize` function once the final size is known.\n *\n * @param options - The options for creating or updating the WAV header.\n * @returns An ArrayBuffer containing the WAV header, or the header combined with the provided audio data.\n *\n * @throws {Error} Throws an error if the provided options are invalid or if the buffer is too small.\n */\nexport const writeWavHeader = ({\n    buffer,\n    sampleRate,\n    numChannels,\n    bitDepth,\n    isFloat = bitDepth === 32, // Default to float for 32-bit\n}: WavHeaderOptions): ArrayBuffer => {\n    // For 32-bit float, we use format 3, otherwise format 1 for PCM\n    const audioFormat = isFloat ? 3 : 1 // 3 = IEEE float, 1 = PCM\n\n    const bytesPerSample = bitDepth / 8\n    const blockAlign = numChannels * bytesPerSample\n    const byteRate = sampleRate * blockAlign\n\n    // Function to write a string to the DataView\n    const writeString = (view: DataView, offset: number, string: string) => {\n        for (let i = 0; i < string.length; i++) {\n            view.setUint8(offset + i, string.charCodeAt(i))\n        }\n    }\n\n    // Function to write or update the header\n    const writeHeader = (view: DataView, dataSize: number = 0xffffffff) => {\n        // RIFF chunk descriptor\n        writeString(view, 0, 'RIFF') // ChunkID\n        view.setUint32(4, 36 + dataSize, true) // ChunkSize: 4 + (8 + 16) + (8 + dataSize)\n        writeString(view, 8, 'WAVE') // Format\n\n        // \"fmt \" sub-chunk\n        writeString(view, 12, 'fmt ') // Subchunk1ID\n        view.setUint32(16, 16, true) // Subchunk1Size (16 for PCM/Float)\n        view.setUint16(20, audioFormat, true) // AudioFormat (3 for float, 1 for PCM)\n        view.setUint16(22, numChannels, true) // NumChannels\n        view.setUint32(24, sampleRate, true) // SampleRate\n        view.setUint32(28, byteRate, true) // ByteRate = SampleRate * NumChannels * BitsPerSample/8\n        view.setUint16(32, blockAlign, true) // BlockAlign = NumChannels * BitsPerSample/8\n        view.setUint16(34, bitDepth, true) // BitsPerSample\n\n        // \"data\" sub-chunk\n        writeString(view, 36, 'data') // Subchunk2ID\n        view.setUint32(40, dataSize, true) // Subchunk2Size = NumSamples * NumChannels * BitsPerSample/8\n    }\n\n    if (buffer) {\n        // Handle existing buffer\n\n        // Check for minimum size\n        if (buffer.byteLength < 44) {\n            throw new Error('Buffer is too small to contain a valid WAV header')\n        }\n\n        const view = new DataView(buffer)\n\n        // Check if the buffer already has a WAV header by looking for \"RIFF\" at the start\n        const existingHeader = view.getUint32(0, false) === 0x52494646 // \"RIFF\" in ASCII\n\n        if (existingHeader) {\n            // Update the existing header\n            writeHeader(view, buffer.byteLength - 44)\n            return buffer\n        } else {\n            // Create a new buffer with header + data\n            const newBuffer = new ArrayBuffer(44 + buffer.byteLength)\n            const newView = new DataView(newBuffer)\n\n            // Write header to new buffer\n            writeHeader(newView, buffer.byteLength)\n\n            // Copy audio data after header\n            new Uint8Array(newBuffer).set(new Uint8Array(buffer), 44)\n            return newBuffer\n        }\n    } else {\n        // Create standalone header\n        const headerBuffer = new ArrayBuffer(44)\n        const view = new DataView(headerBuffer)\n        writeHeader(view)\n        return headerBuffer\n    }\n}\n"]}