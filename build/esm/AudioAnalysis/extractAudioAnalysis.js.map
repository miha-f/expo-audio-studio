{"version":3,"file":"extractAudioAnalysis.js","sourceRoot":"","sources":["../../../src/AudioAnalysis/extractAudioAnalysis.ts"],"names":[],"mappings":"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","sourcesContent":["// packages/expo-audio-stream/src/AudioAnalysis/extractAudioAnalysis.ts\n/**\n * This module provides functions for extracting and analyzing audio data.\n * - `extractAudioAnalysis`: For detailed analysis with customizable ranges and decoding options.\n * - `extractWavAudioAnalysis`: For analyzing WAV files without decoding, preserving original PCM values.\n * - `extractPreview`: For generating quick previews of audio waveforms, optimized for UI rendering.\n */\nimport { ConsoleLike } from '../ExpoAudioStream.types'\nimport ExpoAudioStreamModule from '../ExpoAudioStreamModule'\nimport { isWeb } from '../constants'\nimport {\n    AudioAnalysis,\n    AudioFeaturesOptions,\n    DataPoint,\n    DecodingConfig,\n} from './AudioAnalysis.types'\nimport { processAudioBuffer } from '../utils/audioProcessing'\nimport { convertPCMToFloat32 } from '../utils/convertPCMToFloat32'\nimport crc32 from '../utils/crc32'\nimport { getWavFileInfo, WavFileInfo } from '../utils/getWavFileInfo'\nimport { InlineFeaturesExtractor } from '../workers/InlineFeaturesExtractor.web'\n\nfunction calculateCRC32ForDataPoint(data: Float32Array): number {\n    // Convert float array to byte array for CRC32\n    const byteArray = new Uint8Array(data.length * 4)\n    const dataView = new DataView(byteArray.buffer)\n\n    for (let i = 0; i < data.length; i++) {\n        dataView.setFloat32(i * 4, data[i], true)\n    }\n\n    return crc32.buf(byteArray)\n}\n\nexport interface ExtractWavAudioAnalysisProps {\n    fileUri?: string // should provide either fileUri or arrayBuffer\n    wavMetadata?: WavFileInfo\n    arrayBuffer?: ArrayBuffer\n    bitDepth?: number\n    durationMs?: number\n    sampleRate?: number\n    numberOfChannels?: number\n    position?: number // Optional number of bytes to skip. Default is 0\n    length?: number // Optional number of bytes to read.\n    segmentDurationMs?: number // Optional number of points per second. Use to reduce the number of points and compute the number of datapoints to return.\n    features?: AudioFeaturesOptions\n    featuresExtratorUrl?: string\n    logger?: ConsoleLike\n    decodingOptions?: DecodingConfig\n}\n\n// Define base options interface with common properties\ninterface BaseExtractOptions {\n    fileUri?: string\n    arrayBuffer?: ArrayBuffer\n    /**\n     * Duration of each analysis segment in milliseconds. Defaults to 100ms if not specified.\n     */\n    segmentDurationMs?: number\n    features?: AudioFeaturesOptions\n    decodingOptions?: DecodingConfig\n    logger?: ConsoleLike\n}\n\n// Time-based range options\ninterface TimeRangeOptions extends BaseExtractOptions {\n    startTimeMs?: number\n    endTimeMs?: number\n    position?: never\n    length?: never\n}\n\n// Byte-based range options\ninterface ByteRangeOptions extends BaseExtractOptions {\n    position?: number\n    length?: number\n    startTimeMs?: never\n    endTimeMs?: never\n}\n\n/**\n * Options for extracting audio analysis.\n * - For time-based analysis, provide `startTimeMs` and `endTimeMs`.\n * - For byte-based analysis, provide `position` and `length`.\n * - Do not mix time and byte ranges.\n */\nexport type ExtractAudioAnalysisProps = TimeRangeOptions | ByteRangeOptions\n\n/**\n * Extracts detailed audio analysis from the specified audio file or buffer.\n * Supports either time-based or byte-based ranges for flexibility in analysis.\n *\n * @param props - The options for extraction, including file URI, ranges, and decoding settings.\n * @returns A promise that resolves to the audio analysis data.\n * @throws {Error} If both time and byte ranges are provided or if required parameters are missing.\n */\nexport async function extractAudioAnalysis(\n    props: ExtractAudioAnalysisProps\n): Promise<AudioAnalysis> {\n    const {\n        fileUri,\n        arrayBuffer,\n        decodingOptions,\n        logger,\n        segmentDurationMs = 100,\n        features,\n    } = props\n\n    if (isWeb) {\n        try {\n            // Create AudioContext here\n            const audioContext = new (window.AudioContext ||\n                (window as any).webkitAudioContext)({\n                sampleRate: decodingOptions?.targetSampleRate ?? 16000,\n            })\n\n            try {\n                const processedBuffer = await processAudioBuffer({\n                    arrayBuffer,\n                    fileUri,\n                    targetSampleRate:\n                        decodingOptions?.targetSampleRate ?? 16000,\n                    targetChannels: decodingOptions?.targetChannels ?? 1,\n                    normalizeAudio: decodingOptions?.normalizeAudio ?? false,\n                    startTimeMs:\n                        'startTimeMs' in props ? props.startTimeMs : undefined,\n                    endTimeMs:\n                        'endTimeMs' in props ? props.endTimeMs : undefined,\n                    position: 'position' in props ? props.position : undefined,\n                    length: 'length' in props ? props.length : undefined,\n                    audioContext, // Pass the context we created\n                    logger,\n                })\n\n                const channelData = processedBuffer.buffer.getChannelData(0)\n\n                // Create and initialize the worker\n                const blob = new Blob([InlineFeaturesExtractor], {\n                    type: 'application/javascript',\n                })\n                const workerUrl = URL.createObjectURL(blob)\n                const worker = new Worker(workerUrl)\n\n                return new Promise((resolve, reject) => {\n                    worker.onmessage = (event) => {\n                        if (event.data.error) {\n                            reject(new Error(event.data.error))\n                            return\n                        }\n\n                        const result: AudioAnalysis = event.data.result\n                        // Calculate CRC32 after worker completes if requested\n                        if (features?.crc32) {\n                            const samplesPerSegment = Math.floor(\n                                (processedBuffer.sampleRate *\n                                    segmentDurationMs) /\n                                    1000\n                            )\n\n                            result.dataPoints = result.dataPoints.map(\n                                (point: DataPoint, index: number) => {\n                                    const startSample =\n                                        index * samplesPerSegment\n                                    const segmentData = channelData.slice(\n                                        startSample,\n                                        startSample + samplesPerSegment\n                                    )\n\n                                    return {\n                                        ...point,\n                                        features: {\n                                            ...point.features,\n                                            crc32: calculateCRC32ForDataPoint(\n                                                segmentData\n                                            ),\n                                        },\n                                    }\n                                }\n                            )\n                        }\n\n                        URL.revokeObjectURL(workerUrl)\n                        worker.terminate()\n                        resolve(result)\n                    }\n\n                    worker.onerror = (error) => {\n                        URL.revokeObjectURL(workerUrl)\n                        worker.terminate()\n                        reject(error)\n                    }\n\n                    worker.postMessage({\n                        channelData,\n                        sampleRate: processedBuffer.sampleRate,\n                        segmentDurationMs,\n                        bitDepth: decodingOptions?.targetBitDepth ?? 32,\n                        numberOfChannels: processedBuffer.channels,\n                        fullAudioDurationMs: processedBuffer.durationMs,\n                        // enableLogging: !!logger,\n                        features,\n                    })\n                })\n            } finally {\n                await audioContext.close()\n            }\n        } catch (error) {\n            logger?.error('Failed to process audio:', error)\n            throw error\n        }\n    } else {\n        return await ExpoAudioStreamModule.extractAudioAnalysis(props)\n    }\n}\n\n/**\n * Analyzes WAV files without decoding, preserving original PCM values.\n * Use this function when you need to ensure the analysis matches other software by avoiding any transformations.\n *\n * @param props - The options for WAV analysis, including file URI and range.\n * @returns A promise that resolves to the audio analysis data.\n */\nexport const extractRawWavAnalysis = async ({\n    fileUri,\n    segmentDurationMs = 100, // Default to 100ms\n    arrayBuffer,\n    bitDepth,\n    durationMs,\n    sampleRate,\n    numberOfChannels,\n    features,\n    logger,\n    position = 0,\n    length,\n}: ExtractWavAudioAnalysisProps): Promise<AudioAnalysis> => {\n    if (isWeb) {\n        if (!arrayBuffer && !fileUri) {\n            throw new Error('Either arrayBuffer or fileUri must be provided')\n        }\n\n        if (!arrayBuffer) {\n            logger?.log(`fetching fileUri`, fileUri)\n            const response = await fetch(fileUri!)\n\n            if (!response.ok) {\n                throw new Error(\n                    `Failed to fetch fileUri: ${response.statusText}`\n                )\n            }\n\n            arrayBuffer = await response.arrayBuffer()\n            logger?.log(`fetched fileUri`, arrayBuffer.byteLength, arrayBuffer)\n        }\n\n        // Create a new copy of the ArrayBuffer to avoid detachment issues\n        const bufferCopy = arrayBuffer.slice(0)\n        logger?.log(\n            `extractAudioAnalysis bitDepth=${bitDepth} len=${bufferCopy.byteLength}`,\n            bufferCopy.slice(0, 100)\n        )\n\n        let actualBitDepth = bitDepth\n        if (!actualBitDepth) {\n            logger?.log(\n                `extractAudioAnalysis bitDepth not provided -- getting wav file info`\n            )\n            const fileInfo = await getWavFileInfo(bufferCopy)\n            actualBitDepth = fileInfo.bitDepth\n        }\n        logger?.log(`extractAudioAnalysis actualBitDepth=${actualBitDepth}`)\n\n        const {\n            pcmValues: channelData,\n            min,\n            max,\n        } = await convertPCMToFloat32({\n            buffer: arrayBuffer,\n            bitDepth: actualBitDepth,\n        })\n        logger?.log(\n            `extractAudioAnalysis convertPCMToFloat32 length=${channelData.length} range: [ ${min} :: ${max} ]`\n        )\n\n        // Apply position and length constraints to channelData if specified\n        const startIndex = position\n        const endIndex = length ? startIndex + length : channelData.length\n        const constrainedChannelData = channelData.slice(startIndex, endIndex)\n\n        return new Promise((resolve, reject) => {\n            const blob = new Blob([InlineFeaturesExtractor], {\n                type: 'application/javascript',\n            })\n            const url = URL.createObjectURL(blob)\n            const worker = new Worker(url)\n\n            worker.onmessage = (event) => {\n                resolve(event.data.result)\n            }\n\n            worker.onerror = (error) => {\n                reject(error)\n            }\n\n            worker.postMessage({\n                command: 'process',\n                channelData: constrainedChannelData,\n                sampleRate,\n                segmentDurationMs,\n                logger,\n                bitDepth,\n                fullAudioDurationMs: durationMs,\n                numberOfChannels,\n            })\n        })\n    } else {\n        if (!fileUri) {\n            throw new Error('fileUri is required')\n        }\n        logger?.log(`extractAudioAnalysis`, {\n            fileUri,\n            segmentDurationMs,\n        })\n        const res = await ExpoAudioStreamModule.extractAudioAnalysis({\n            fileUri,\n            segmentDurationMs,\n            features,\n            position,\n            length,\n        })\n        logger?.log(`extractAudioAnalysis`, res)\n        return res\n    }\n}\n"]}