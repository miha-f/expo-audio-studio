{"version":3,"file":"convertPCMToFloat32.js","sourceRoot":"","sources":["../../../src/utils/convertPCMToFloat32.ts"],"names":[],"mappings":"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","sourcesContent":["import { Platform } from 'react-native'\n\nimport { ConsoleLike } from '../ExpoAudioStream.types'\nimport { getWavFileInfo, WavFileInfo } from './getWavFileInfo'\n\nexport const WAV_HEADER_SIZE = 44\n\nconst convertSample = (\n    dataView: DataView,\n    offset: number,\n    bitDepth: number\n): number => {\n    switch (bitDepth) {\n        case 8:\n            return (dataView.getUint8(offset) - 128) / 128\n        case 16:\n            return dataView.getInt16(offset, true) / 32768\n        case 24:\n            return (\n                ((dataView.getUint8(offset) |\n                    (dataView.getUint8(offset + 1) << 8) |\n                    (dataView.getUint8(offset + 2) << 16)) /\n                    8388608) *\n                    2 -\n                1\n            )\n        case 32:\n            return dataView.getFloat32(offset, true)\n        default:\n            throw new Error(`Unsupported bit depth: ${bitDepth}`)\n    }\n}\n\nconst convertSampleNative = (\n    array: Uint8Array,\n    startIndex: number,\n    bitDepth: number\n): number => {\n    switch (bitDepth) {\n        case 8:\n            return (array[startIndex] - 128) / 128\n        case 16: {\n            // Handle 16-bit PCM using Uint8Array directly\n            const low = array[startIndex]\n            const high = array[startIndex + 1]\n            const value = (high << 8) | low\n            // Convert to signed 16-bit\n            return (value > 32767 ? value - 65536 : value) / 32768\n        }\n        case 24: {\n            const byte1 = array[startIndex]\n            const byte2 = array[startIndex + 1]\n            const byte3 = array[startIndex + 2]\n            const value = (byte3 << 16) | (byte2 << 8) | byte1\n            return (\n                ((value > 8388607 ? value - 16777216 : value) / 8388608) * 2 - 1\n            )\n        }\n        case 32: {\n            // Assuming 32-bit float\n            const view = new DataView(array.buffer, startIndex, 4)\n            return view.getFloat32(0, true)\n        }\n        default:\n            throw new Error(`Unsupported bit depth: ${bitDepth}`)\n    }\n}\n\nexport const convertPCMToFloat32 = async ({\n    bitDepth,\n    buffer,\n    skipWavHeader = false,\n    logger,\n}: {\n    buffer: ArrayBuffer\n    bitDepth: number\n    skipWavHeader?: boolean\n    logger?: ConsoleLike\n}): Promise<{ pcmValues: Float32Array; min: number; max: number }> => {\n    try {\n        logger?.debug(\n            `Converting PCM to Float32: bitDepth: ${bitDepth}, buffer.byteLength: ${buffer.byteLength}`\n        )\n\n        let headerOffset = 0\n        if (!skipWavHeader) {\n            const wavFileInfo: WavFileInfo = await getWavFileInfo(buffer)\n            headerOffset = wavFileInfo.dataChunkOffset\n            logger?.debug(`Using WAV header offset: ${headerOffset}`)\n        }\n\n        // Convert ArrayBuffer to Uint8Array for more efficient native handling\n        const uint8Array = new Uint8Array(buffer)\n        const dataLength = buffer.byteLength - headerOffset\n        const bytesPerSample = bitDepth / 8\n        const sampleLength = Math.floor(dataLength / bytesPerSample)\n\n        // Create result array using SharedArrayBuffer for better memory handling\n        let float32Array: Float32Array\n        try {\n            // Try using SharedArrayBuffer first\n            const sharedBuffer = new SharedArrayBuffer(sampleLength * 4)\n            float32Array = new Float32Array(sharedBuffer)\n        } catch (e) {\n            // Fallback to regular ArrayBuffer if SharedArrayBuffer is not available\n            float32Array = new Float32Array(sampleLength)\n        }\n\n        let min = Infinity\n        let max = -Infinity\n\n        // Process in smaller chunks\n        const CHUNK_SIZE = Platform.OS === 'web' ? sampleLength : 4000 // Smaller chunks for native\n        const numChunks = Math.ceil(sampleLength / CHUNK_SIZE)\n\n        for (let chunk = 0; chunk < numChunks; chunk++) {\n            const startSample = chunk * CHUNK_SIZE\n            const endSample = Math.min((chunk + 1) * CHUNK_SIZE, sampleLength)\n\n            // Process chunk\n            for (let i = startSample; i < endSample; i++) {\n                const startIndex = headerOffset + i * bytesPerSample\n                if (startIndex + bytesPerSample <= uint8Array.length) {\n                    const value =\n                        Platform.OS === 'web'\n                            ? convertSample(\n                                  new DataView(buffer),\n                                  startIndex,\n                                  bitDepth\n                              )\n                            : convertSampleNative(\n                                  uint8Array,\n                                  startIndex,\n                                  bitDepth\n                              )\n\n                    if (isFinite(value)) {\n                        float32Array[i] = value\n                        min = Math.min(min, value)\n                        max = Math.max(max, value)\n                    }\n                }\n            }\n\n            // Allow garbage collection between chunks on native\n            if (Platform.OS !== 'web' && chunk < numChunks - 1) {\n                await new Promise((resolve) => setTimeout(resolve, 0))\n            }\n        }\n\n        logger?.debug(\n            `Conversion complete. Length: ${float32Array.length}, Range: [${min}, ${max}]`\n        )\n\n        // Only log a small sample of values to avoid memory issues\n        if (logger?.debug) {\n            const sampleValues = Array.from(float32Array.slice(0, 5))\n            logger.debug('Sample values:', sampleValues)\n        }\n\n        return {\n            pcmValues: float32Array,\n            min,\n            max,\n        }\n    } catch (error: unknown) {\n        logger?.error(`Error converting PCM to Float32`, error)\n        throw error\n    }\n}\n"]}