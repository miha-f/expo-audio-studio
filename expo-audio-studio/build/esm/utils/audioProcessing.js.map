{"version":3,"file":"audioProcessing.js","sourceRoot":"","sources":["../../../src/utils/audioProcessing.ts"],"names":[],"mappings":"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","sourcesContent":["// packages/expo-audio-stream/src/utils/audioProcessing.ts\nimport { Platform } from 'react-native'\n\nimport { ConsoleLike } from '../ExpoAudioStream.types'\n\nexport interface ProcessAudioBufferOptions {\n    arrayBuffer?: ArrayBuffer\n    fileUri?: string\n    targetSampleRate: number\n    targetChannels: number\n    normalizeAudio: boolean\n    startTimeMs?: number\n    endTimeMs?: number\n    position?: number\n    length?: number\n    audioContext?: AudioContext\n    logger?: ConsoleLike\n}\n\nexport interface ProcessedAudioData {\n    channelData: Float32Array\n    samples: number\n    durationMs: number\n    sampleRate: number\n    channels: number\n    buffer: AudioBuffer\n}\n\nexport async function processAudioBuffer({\n    arrayBuffer,\n    fileUri,\n    targetSampleRate,\n    targetChannels,\n    normalizeAudio,\n    startTimeMs,\n    endTimeMs,\n    position,\n    length,\n    audioContext,\n    logger,\n}: ProcessAudioBufferOptions): Promise<ProcessedAudioData> {\n    if (Platform.OS !== 'web') {\n        throw new Error('processAudioBuffer is only supported on web')\n    }\n\n    let ctx: AudioContext | undefined\n    let buffer: AudioBuffer | undefined\n\n    try {\n        // Log initial parameters\n        logger?.debug('Process audio buffer - Initial params:', {\n            hasArrayBuffer: !!arrayBuffer,\n            fileUri,\n            targetSampleRate,\n            targetChannels,\n            normalizeAudio,\n            startTimeMs,\n            endTimeMs,\n            position,\n            length,\n        })\n\n        // Get the audio data\n        let audioData: ArrayBuffer\n        if (arrayBuffer) {\n            audioData = arrayBuffer\n        } else if (fileUri) {\n            const response = await fetch(fileUri)\n            if (!response.ok) {\n                throw new Error(\n                    `Failed to fetch fileUri: ${response.statusText}`\n                )\n            }\n            audioData = await response.arrayBuffer()\n        } else {\n            throw new Error('Either arrayBuffer or fileUri must be provided')\n        }\n\n        logger?.debug('Audio data loaded:', {\n            byteLength: audioData.byteLength,\n            firstBytes: Array.from(new Uint8Array(audioData.slice(0, 16))),\n        })\n\n        // Create context at original sample rate first\n        ctx =\n            audioContext ||\n            new (window.AudioContext || (window as any).webkitAudioContext)()\n        buffer = await ctx.decodeAudioData(audioData)\n\n        logger?.debug('Decoded audio buffer:', {\n            originalChannels: buffer.numberOfChannels,\n            originalSampleRate: buffer.sampleRate,\n            originalDuration: buffer.duration,\n            originalLength: buffer.length,\n        })\n\n        // Calculate time range\n        const startSample =\n            startTimeMs !== undefined\n                ? Math.floor((startTimeMs / 1000) * buffer.sampleRate)\n                : position !== undefined\n                  ? Math.floor(position / 2)\n                  : 0\n\n        // Fix: Adjust position calculation based on original sample rate\n        // When position is provided in bytes, we need to account for the original sample rate\n        const bytesPerSample = 2 // 16-bit audio = 2 bytes per sample\n        const adjustedStartSample =\n            position !== undefined\n                ? Math.floor(\n                      (position / bytesPerSample) *\n                          (buffer.sampleRate / targetSampleRate)\n                  )\n                : startSample\n\n        const samplesNeeded =\n            length !== undefined\n                ? Math.floor(\n                      (length / bytesPerSample) *\n                          (buffer.sampleRate / targetSampleRate)\n                  )\n                : endTimeMs !== undefined && startTimeMs !== undefined\n                  ? Math.floor(\n                        ((endTimeMs - startTimeMs) / 1000) * buffer.sampleRate\n                    )\n                  : buffer.length - adjustedStartSample\n\n        logger?.debug('Sample calculations (adjusted):', {\n            originalStartSample: startSample,\n            adjustedStartSample,\n            samplesNeeded,\n            originalSampleRate: buffer.sampleRate,\n            targetSampleRate,\n            conversionRatio: buffer.sampleRate / targetSampleRate,\n            expectedDurationMs: (samplesNeeded / buffer.sampleRate) * 1000,\n        })\n\n        // Create temporary buffer for the segment\n        const segmentBuffer = ctx.createBuffer(\n            buffer.numberOfChannels,\n            samplesNeeded,\n            buffer.sampleRate\n        )\n\n        // Copy the segment\n        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {\n            const channelData = buffer.getChannelData(channel)\n            const segmentData = segmentBuffer.getChannelData(channel)\n            for (let i = 0; i < samplesNeeded; i++) {\n                segmentData[i] = channelData[adjustedStartSample + i]\n            }\n        }\n\n        // Create offline context for resampling\n        const offlineCtx = new OfflineAudioContext(\n            targetChannels,\n            Math.ceil((samplesNeeded * targetSampleRate) / buffer.sampleRate),\n            targetSampleRate\n        )\n\n        // Create source and connect\n        const source = offlineCtx.createBufferSource()\n        source.buffer = segmentBuffer\n        source.connect(offlineCtx.destination)\n\n        // Render at new sample rate\n        source.start()\n        const processedBuffer = await offlineCtx.startRendering()\n\n        // Get the final audio data\n        const channelData = processedBuffer.getChannelData(0)\n        const durationMs = Math.round(\n            (samplesNeeded / buffer.sampleRate) * 1000\n        )\n\n        logger?.debug('Final processed audio:', {\n            outputSamples: channelData.length,\n            outputSampleRate: targetSampleRate,\n            durationMs,\n        })\n\n        return {\n            buffer: processedBuffer,\n            channelData,\n            samples: channelData.length,\n            durationMs,\n            sampleRate: targetSampleRate,\n            channels: processedBuffer.numberOfChannels,\n        }\n    } catch (error) {\n        logger?.error('Failed to process audio buffer:', {\n            error,\n            position,\n            length,\n            startTimeMs,\n            endTimeMs,\n            bufferLength: buffer?.length,\n        })\n        throw error\n    } finally {\n        if (!audioContext && ctx) {\n            await ctx.close()\n        }\n    }\n}\n"]}