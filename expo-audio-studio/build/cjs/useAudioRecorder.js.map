{"version":3,"file":"useAudioRecorder.js","sourceRoot":"","sources":["../../src/useAudioRecorder.tsx"],"names":[],"mappings":"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","sourcesContent":["// src/useAudioRecorder.ts\nimport { EventSubscription, Platform } from 'expo-modules-core'\nimport { useCallback, useEffect, useReducer, useRef, useId } from 'react'\n\nimport { AudioAnalysis } from './AudioAnalysis/AudioAnalysis.types'\nimport { audioDeviceManager } from './AudioDeviceManager'\nimport {\n    AudioDataEvent,\n    AudioRecording,\n    AudioStreamStatus,\n    CompressionInfo,\n    ConsoleLike,\n    RecordingConfig,\n    StartRecordingResult,\n} from './ExpoAudioStream.types'\nimport ExpoAudioStreamModule from './ExpoAudioStreamModule'\nimport {\n    addAudioAnalysisListener,\n    addAudioEventListener,\n    AudioEventPayload,\n    addRecordingInterruptionListener,\n} from './events'\n\nexport interface UseAudioRecorderProps {\n    logger?: ConsoleLike\n    audioWorkletUrl?: string\n    featuresExtratorUrl?: string\n}\n\nexport interface UseAudioRecorderState {\n    prepareRecording: (_: RecordingConfig) => Promise<void>\n    startRecording: (_: RecordingConfig) => Promise<StartRecordingResult>\n    stopRecording: () => Promise<AudioRecording>\n    pauseRecording: () => Promise<void>\n    resumeRecording: () => Promise<void>\n    isRecording: boolean\n    isPaused: boolean\n    durationMs: number\n    size: number\n    compression?: CompressionInfo\n    analysisData?: AudioAnalysis\n}\n\ninterface RecorderReducerState {\n    isRecording: boolean\n    isPaused: boolean\n    durationMs: number\n    size: number\n    compression?: CompressionInfo\n    analysisData?: AudioAnalysis\n}\n\ntype RecorderAction =\n    | { type: 'START' | 'STOP' | 'PAUSE' | 'RESUME' }\n    | {\n          type: 'UPDATE_RECORDING_STATE'\n          payload: {\n              isRecording: boolean\n              isPaused: boolean\n          }\n      }\n    | {\n          type: 'UPDATE_STATUS'\n          payload: {\n              durationMs: number\n              size: number\n              compression?: CompressionInfo\n          }\n      }\n    | { type: 'UPDATE_ANALYSIS'; payload: AudioAnalysis }\n\nconst defaultAnalysis: AudioAnalysis = {\n    segmentDurationMs: 100,\n    bitDepth: 32,\n    numberOfChannels: 1,\n    durationMs: 0,\n    sampleRate: 44100,\n    samples: 0,\n    dataPoints: [],\n    rmsRange: {\n        min: Number.POSITIVE_INFINITY,\n        max: Number.NEGATIVE_INFINITY,\n    },\n    amplitudeRange: {\n        min: Number.POSITIVE_INFINITY,\n        max: Number.NEGATIVE_INFINITY,\n    },\n    extractionTimeMs: 0,\n}\n\nfunction audioRecorderReducer(\n    state: RecorderReducerState,\n    action: RecorderAction\n): RecorderReducerState {\n    switch (action.type) {\n        case 'START':\n            return {\n                ...state,\n                isRecording: true,\n                isPaused: false,\n                durationMs: 0,\n                size: 0,\n                compression: undefined,\n                analysisData: defaultAnalysis,\n            }\n        case 'STOP':\n            return {\n                ...state,\n                isRecording: false,\n                isPaused: false,\n                durationMs: 0,\n                size: 0,\n                compression: undefined,\n                analysisData: undefined,\n            }\n        case 'PAUSE':\n            return { ...state, isPaused: true, isRecording: false }\n        case 'RESUME':\n            return { ...state, isPaused: false, isRecording: true }\n        case 'UPDATE_RECORDING_STATE':\n            return {\n                ...state,\n                isPaused: action.payload.isPaused,\n                isRecording: action.payload.isRecording,\n            }\n        case 'UPDATE_STATUS': {\n            const newState = {\n                ...state,\n                durationMs: action.payload.durationMs,\n                size: action.payload.size,\n                compression: action.payload.compression\n                    ? {\n                          size: action.payload.compression.size,\n                          mimeType: action.payload.compression.mimeType,\n                          bitrate: action.payload.compression.bitrate,\n                          format: action.payload.compression.format,\n                      }\n                    : undefined,\n            }\n            return newState\n        }\n        case 'UPDATE_ANALYSIS':\n            return {\n                ...state,\n                analysisData: action.payload,\n            }\n        default:\n            return state\n    }\n}\n\ninterface HandleAudioAnalysisProps {\n    analysis: AudioAnalysis\n    visualizationDuration: number\n}\n\nexport function useAudioRecorder({\n    logger,\n    audioWorkletUrl,\n    featuresExtratorUrl,\n}: UseAudioRecorderProps = {}): UseAudioRecorderState {\n    // Initialize AudioDeviceManager with logger (once)\n    if (logger) {\n        audioDeviceManager.setLogger(logger)\n    }\n    const [state, dispatch] = useReducer(audioRecorderReducer, {\n        isRecording: false,\n        isPaused: false,\n        durationMs: 0,\n        size: 0,\n        compression: undefined,\n        analysisData: undefined,\n    })\n\n    const startResultRef = useRef<StartRecordingResult | null>(null)\n\n    const analysisListenerRef = useRef<EventSubscription | null>(null)\n    // analysisRef is the current analysis data (last 10 seconds by default)\n    const analysisRef = useRef<AudioAnalysis>({ ...defaultAnalysis })\n    // fullAnalysisRef is the full analysis data (all data points)\n    const fullAnalysisRef = useRef<AudioAnalysis>({\n        ...defaultAnalysis,\n    })\n\n    // Instantiate the module for web with URLs\n    const ExpoAudioStream =\n        Platform.OS === 'web'\n            ? ExpoAudioStreamModule({\n                  audioWorkletUrl,\n                  featuresExtratorUrl,\n                  logger,\n              })\n            : ExpoAudioStreamModule\n\n    const onAudioStreamRef = useRef<\n        ((_: AudioDataEvent) => Promise<void>) | null\n    >(null)\n\n    const stateRef = useRef({\n        isRecording: false,\n        isPaused: false,\n        durationMs: 0,\n        size: 0,\n        compression: undefined as CompressionInfo | undefined,\n    })\n\n    const recordingConfigRef = useRef<RecordingConfig | null>(null)\n\n    // Generate unique instance ID for debugging\n    const instanceId = useId().replace(/:/g, '').slice(0, 5)\n\n    const handleAudioAnalysis = useCallback(\n        async ({\n            analysis,\n            visualizationDuration,\n        }: HandleAudioAnalysisProps) => {\n            const savedAnalysisData = analysisRef.current || {\n                ...defaultAnalysis,\n            }\n\n            const maxDuration = visualizationDuration\n\n            logger?.debug(\n                `[handleAudioAnalysis] Received audio analysis: maxDuration=${maxDuration} analysis.dataPoints=${analysis.dataPoints.length} analysisData.dataPoints=${savedAnalysisData.dataPoints.length}`\n            )\n\n            // Combine data points\n            const combinedDataPoints = [\n                ...savedAnalysisData.dataPoints,\n                ...analysis.dataPoints,\n            ]\n\n            const fullCombinedDataPoints = [\n                ...(fullAnalysisRef.current?.dataPoints ?? []),\n                ...analysis.dataPoints,\n            ]\n\n            // Calculate the new duration\n            // The number of segments is based on how many segments of segmentDurationMs can fit in visualizationDuration\n            const numberOfSegments = Math.ceil(\n                visualizationDuration / analysis.segmentDurationMs\n            )\n            // maxDataPoints should be the number of data points, not milliseconds\n            const maxDataPoints = numberOfSegments\n\n            logger?.debug(\n                `[handleAudioAnalysis] Combined data points before trimming: numberOfSegments=${numberOfSegments} visualizationDuration=${visualizationDuration} combinedDataPointsLength=${combinedDataPoints.length} vs maxDataPoints=${maxDataPoints}`\n            )\n\n            // Trim data points to keep within the maximum number of data points\n            if (combinedDataPoints.length > maxDataPoints) {\n                combinedDataPoints.splice(\n                    0,\n                    combinedDataPoints.length - maxDataPoints\n                )\n            }\n\n            // Keep the full data points\n            fullAnalysisRef.current = {\n                ...fullAnalysisRef.current,\n                dataPoints: fullCombinedDataPoints,\n            }\n            fullAnalysisRef.current.durationMs =\n                fullCombinedDataPoints.length * analysis.segmentDurationMs\n            savedAnalysisData.dataPoints = combinedDataPoints\n            savedAnalysisData.bitDepth =\n                analysis.bitDepth || savedAnalysisData.bitDepth\n            savedAnalysisData.durationMs =\n                combinedDataPoints.length * analysis.segmentDurationMs\n\n            // Update amplitude range\n            const newMin = Math.min(\n                savedAnalysisData.amplitudeRange.min,\n                analysis.amplitudeRange.min\n            )\n            const newMax = Math.max(\n                savedAnalysisData.amplitudeRange.max,\n                analysis.amplitudeRange.max\n            )\n\n            savedAnalysisData.amplitudeRange = {\n                min: newMin,\n                max: newMax,\n            }\n            fullAnalysisRef.current.amplitudeRange = {\n                min: newMin,\n                max: newMax,\n            }\n\n            logger?.debug(\n                `[handleAudioAnalysis] Updated analysis data: durationMs=${savedAnalysisData.durationMs}`,\n                { dataPoints: savedAnalysisData.dataPoints.length }\n            )\n\n            // Call the onAudioAnalysis callback if it exists in the recording config\n            if (recordingConfigRef.current?.onAudioAnalysis) {\n                recordingConfigRef.current\n                    .onAudioAnalysis(analysis)\n                    .catch((error) => {\n                        logger?.warn(`Error processing audio analysis:`, error)\n                    })\n            }\n\n            // Update the ref\n            analysisRef.current = savedAnalysisData\n\n            // Dispatch the updated analysis data to state to trigger re-render\n            dispatch({\n                type: 'UPDATE_ANALYSIS',\n                payload: { ...savedAnalysisData },\n            })\n        },\n        [dispatch]\n    )\n\n    const handleAudioEvent = useCallback(\n        async (eventData: AudioEventPayload) => {\n            const {\n                fileUri,\n                deltaSize,\n                totalSize,\n                lastEmittedSize,\n                position,\n                streamUuid,\n                encoded,\n                mimeType,\n                buffer,\n                compression,\n            } = eventData\n            logger?.debug(`[handleAudioEvent] Received audio event:`, {\n                fileUri,\n                deltaSize,\n                totalSize,\n                position,\n                mimeType,\n                lastEmittedSize,\n                streamUuid,\n                encodedLength: encoded?.length,\n                compression,\n            })\n            if (deltaSize === 0) {\n                // Ignore packet with no data\n                return\n            }\n            try {\n                // Coming from native ( ios / android ) otherwise buffer is set\n                if (Platform.OS !== 'web') {\n                    // Read the audio file as a base64 string for comparison\n                    if (!encoded) {\n                        logger?.error(`Encoded audio data is missing`)\n                        throw new Error('Encoded audio data is missing')\n                    }\n                    onAudioStreamRef.current?.({\n                        data: encoded,\n                        position,\n                        fileUri,\n                        eventDataSize: deltaSize,\n                        totalSize,\n                        compression:\n                            compression && startResultRef.current?.compression\n                                ? {\n                                      data: compression.data,\n                                      size: compression.totalSize,\n                                      mimeType:\n                                          startResultRef.current.compression\n                                              ?.mimeType,\n                                      bitrate:\n                                          startResultRef.current.compression\n                                              ?.bitrate,\n                                      format: startResultRef.current.compression\n                                          ?.format,\n                                  }\n                                : undefined,\n                    })\n                } else if (buffer) {\n                    // Coming from web\n                    const webEvent: AudioDataEvent = {\n                        data: buffer,\n                        position,\n                        fileUri,\n                        eventDataSize: deltaSize,\n                        totalSize,\n                        compression:\n                            compression && startResultRef.current?.compression\n                                ? {\n                                      data: compression.data,\n                                      size: compression.totalSize,\n                                      mimeType:\n                                          startResultRef.current.compression\n                                              ?.mimeType,\n                                      bitrate:\n                                          startResultRef.current.compression\n                                              ?.bitrate,\n                                      format: startResultRef.current.compression\n                                          ?.format,\n                                  }\n                                : undefined,\n                    }\n                    onAudioStreamRef.current?.(webEvent)\n                    logger?.debug(\n                        `[handleAudioEvent] Audio data sent to onAudioStream`,\n                        webEvent\n                    )\n                }\n            } catch (error) {\n                logger?.error(`Error processing audio event:`, error)\n            }\n        },\n        []\n    )\n\n    const checkStatus = useCallback(async () => {\n        try {\n            const status: AudioStreamStatus = ExpoAudioStream.status()\n            logger?.debug(\n                `Status: paused: ${status.isPaused} isRecording: ${status.isRecording} durationMs: ${status.durationMs} size: ${status.size}`,\n                status.compression\n            )\n\n            // Only dispatch if values actually changed\n            if (\n                status.isRecording !== stateRef.current.isRecording ||\n                status.isPaused !== stateRef.current.isPaused\n            ) {\n                stateRef.current.isRecording = status.isRecording\n                stateRef.current.isPaused = status.isPaused\n                dispatch({\n                    type: 'UPDATE_RECORDING_STATE',\n                    payload: {\n                        isRecording: status.isRecording,\n                        isPaused: status.isPaused,\n                    },\n                })\n            }\n\n            if (\n                status.durationMs !== stateRef.current.durationMs ||\n                status.size !== stateRef.current.size\n            ) {\n                stateRef.current.durationMs = status.durationMs\n                stateRef.current.size = status.size\n                stateRef.current.compression = status.compression\n                dispatch({\n                    type: 'UPDATE_STATUS',\n                    payload: {\n                        durationMs: status.durationMs,\n                        size: status.size,\n                        compression: status.compression,\n                    },\n                })\n            }\n        } catch (error) {\n            logger?.error(`Error getting status:`, error)\n        }\n    }, [ExpoAudioStream, logger]) // Only depend on ExpoAudioStream and logger\n\n    // Update ref when state changes\n    useEffect(() => {\n        stateRef.current = {\n            isRecording: state.isRecording,\n            isPaused: state.isPaused,\n            durationMs: state.durationMs,\n            size: state.size,\n            compression: state.compression,\n        }\n    }, [\n        state.isRecording,\n        state.isPaused,\n        state.durationMs,\n        state.size,\n        state.compression,\n    ])\n\n    const startRecording = useCallback(\n        async (recordingOptions: RecordingConfig) => {\n            // Import validation function\n            const { validateRecordingConfig } = await import(\n                './constants/platformLimitations'\n            )\n\n            // Validate the encoding configuration\n            const validationResult = validateRecordingConfig({\n                encoding: recordingOptions.encoding,\n            })\n\n            // Log warnings if any\n            if (validationResult.warnings.length > 0) {\n                validationResult.warnings.forEach((warning) => {\n                    logger?.warn(warning)\n                })\n            }\n\n            // Update recording options with validated values\n            const validatedOptions = {\n                ...recordingOptions,\n                encoding: validationResult.encoding,\n            }\n\n            recordingConfigRef.current = validatedOptions\n            logger?.debug(\n                `start recording with validated config`,\n                validatedOptions\n            )\n\n            analysisRef.current = { ...defaultAnalysis } // Reset analysis data\n            fullAnalysisRef.current = { ...defaultAnalysis }\n            const {\n                onAudioStream,\n                onRecordingInterrupted,\n                onAudioAnalysis,\n                ...options\n            } = validatedOptions\n            const { enableProcessing } = options\n\n            const maxRecentDataDuration = 10000 // TODO compute maxRecentDataDuration based on screen dimensions\n            if (typeof onAudioStream === 'function') {\n                onAudioStreamRef.current = onAudioStream\n            } else {\n                logger?.warn(`onAudioStream is not a function`, onAudioStream)\n                onAudioStreamRef.current = null\n            }\n            const startResult: StartRecordingResult =\n                await ExpoAudioStream.startRecording(options)\n            dispatch({ type: 'START' })\n\n            startResultRef.current = startResult\n\n            if (enableProcessing) {\n                logger?.debug(`Enabling audio analysis listener`)\n                const listener = addAudioAnalysisListener(\n                    async (analysisData) => {\n                        try {\n                            await handleAudioAnalysis({\n                                analysis: analysisData,\n                                visualizationDuration: maxRecentDataDuration,\n                            })\n                        } catch (error) {\n                            logger?.warn(\n                                `Error processing audio analysis:`,\n                                error\n                            )\n                        }\n                    }\n                )\n\n                analysisListenerRef.current = listener\n            }\n\n            return startResult\n        },\n        [handleAudioAnalysis, dispatch]\n    )\n\n    const prepareRecording = useCallback(\n        async (recordingOptions: RecordingConfig) => {\n            recordingConfigRef.current = recordingOptions\n            logger?.debug(`preparing recording`, recordingOptions)\n\n            analysisRef.current = { ...defaultAnalysis } // Reset analysis data\n            fullAnalysisRef.current = { ...defaultAnalysis }\n            const {\n                onAudioStream,\n                onRecordingInterrupted,\n                onAudioAnalysis,\n                ...options\n            } = recordingOptions\n\n            // Store onAudioStream for later use when recording starts\n            if (typeof onAudioStream === 'function') {\n                onAudioStreamRef.current = onAudioStream\n            } else {\n                logger?.warn(`onAudioStream is not a function`, onAudioStream)\n                onAudioStreamRef.current = null\n            }\n\n            // Call the native prepareRecording method\n            await ExpoAudioStream.prepareRecording(options)\n            logger?.debug(`recording prepared successfully`)\n        },\n        []\n    )\n\n    const stopRecording = useCallback(async () => {\n        logger?.debug(`stoping recording`)\n\n        const stopResult: AudioRecording = await ExpoAudioStream.stopRecording()\n        stopResult.analysisData = fullAnalysisRef.current\n\n        if (analysisListenerRef.current) {\n            analysisListenerRef.current.remove()\n            analysisListenerRef.current = null\n        }\n        onAudioStreamRef.current = null\n\n        // Note: We deliberately DON'T clear recordingConfigRef here to preserve interruption callback\n        logger?.debug(`recording stopped`, stopResult)\n        dispatch({ type: 'STOP' })\n        return stopResult\n    }, [dispatch])\n\n    const pauseRecording = useCallback(async () => {\n        logger?.debug(`pause recording`)\n        const pauseResult = await ExpoAudioStream.pauseRecording()\n        dispatch({ type: 'PAUSE' })\n        return pauseResult\n    }, [dispatch])\n\n    const resumeRecording = useCallback(async () => {\n        logger?.debug(`resume recording`)\n        const resumeResult = await ExpoAudioStream.resumeRecording()\n        dispatch({ type: 'RESUME' })\n        return resumeResult\n    }, [dispatch])\n\n    useEffect(() => {\n        let intervalId: ReturnType<typeof setInterval> | undefined\n\n        if (state.isRecording || state.isPaused) {\n            // Immediately check status when starting\n            checkStatus()\n\n            // Start interval\n            intervalId = setInterval(checkStatus, 1000)\n        }\n\n        return () => {\n            if (intervalId) {\n                clearInterval(intervalId)\n                intervalId = undefined\n            }\n        }\n    }, [checkStatus, state.isRecording, state.isPaused])\n\n    useEffect(() => {\n        logger?.debug(`Registering audio event listener`)\n        const subscribeAudio = addAudioEventListener(handleAudioEvent)\n\n        logger?.debug(\n            `Subscribed to audio event listener and analysis listener`,\n            {\n                subscribeAudio,\n            }\n        )\n\n        return () => {\n            logger?.debug(`Removing audio event listener`)\n            subscribeAudio.remove()\n        }\n    }, [handleAudioEvent, handleAudioAnalysis])\n\n    useEffect(() => {\n        // Add event subscription for recording interruptions\n        logger?.debug(\n            `Setting up recording interruption listener [${instanceId}]`\n        )\n\n        const subscription = addRecordingInterruptionListener((event) => {\n            logger?.debug(\n                `[${instanceId}] Received recording interruption event:`,\n                event\n            )\n\n            // Handle device disconnection for UI updates\n            if (event.reason === 'deviceDisconnected') {\n                logger?.debug(\n                    `[${instanceId}] Device disconnected - temporarily hiding last device from UI`\n                )\n\n                // Get current device list before the native layer updates\n                const currentDevices = audioDeviceManager.getRawDevices()\n\n                // Wait a moment for native layer to update, then compare\n                setTimeout(async () => {\n                    try {\n                        // Get updated devices without notifying yet\n                        const updatedDevices =\n                            await audioDeviceManager.getAvailableDevices({\n                                refresh: true,\n                            })\n\n                        // Find missing devices by comparing lists\n                        const missingDevices = currentDevices.filter(\n                            (oldDevice) =>\n                                !updatedDevices.some(\n                                    (newDevice) => newDevice.id === oldDevice.id\n                                )\n                        )\n\n                        if (missingDevices.length > 0) {\n                            // Mark all missing devices as disconnected (silently)\n                            missingDevices.forEach((missingDevice) => {\n                                logger?.debug(\n                                    `[${instanceId}] Confirmed disconnected device: ${missingDevice.name} (${missingDevice.id})`\n                                )\n                                audioDeviceManager.markDeviceAsDisconnected(\n                                    missingDevice.id,\n                                    false\n                                )\n                            })\n                        }\n\n                        // Notify listeners once with the final filtered state\n                        audioDeviceManager.notifyListeners()\n                    } catch (error) {\n                        logger?.warn(\n                            `[${instanceId}] Error in delayed device disconnection handling:`,\n                            error\n                        )\n                    }\n                }, 500) // 500ms delay to let native layer update\n            } else if (event.reason === 'deviceConnected') {\n                // Device reconnected - force refresh to show it immediately\n                logger?.debug(\n                    `[${instanceId}] Device connected, forcing refresh`\n                )\n                audioDeviceManager.forceRefreshDevices()\n            }\n\n            // Check if we have a callback configured\n            logger?.debug(\n                `[${instanceId}] recordingConfigRef.current exists:`,\n                !!recordingConfigRef.current\n            )\n\n            if (recordingConfigRef.current?.onRecordingInterrupted) {\n                try {\n                    logger?.debug(\n                        `[${instanceId}] Calling recording interruption callback`\n                    )\n                    recordingConfigRef.current.onRecordingInterrupted(event)\n                } catch (error) {\n                    logger?.error(\n                        `[${instanceId}] Error in recording interruption callback:`,\n                        error\n                    )\n                }\n            } else {\n                logger?.debug(\n                    `[${instanceId}] No recording interruption callback configured`\n                )\n            }\n        })\n\n        return () => {\n            logger?.debug(\n                `[${instanceId}] Removing recording interruption listener`\n            )\n            subscription.remove()\n        }\n    }, [instanceId, logger]) // Include instanceId and logger in dependencies\n\n    return {\n        prepareRecording,\n        startRecording,\n        stopRecording,\n        pauseRecording,\n        resumeRecording,\n        isPaused: state.isPaused,\n        isRecording: state.isRecording,\n        durationMs: state.durationMs,\n        size: state.size,\n        compression: state.compression,\n        analysisData: state.analysisData,\n    }\n}\n"]}