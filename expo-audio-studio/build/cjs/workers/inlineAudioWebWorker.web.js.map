{"version":3,"file":"inlineAudioWebWorker.web.js","sourceRoot":"","sources":["../../../src/workers/inlineAudioWebWorker.web.tsx"],"names":[],"mappings":";;;AAAA,sEAAsE;AACzD,QAAA,oBAAoB,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkLnC,CAAA","sourcesContent":["// packages/expo-audio-stream/src/workers/inlineAudioWebWorker.web.tsx\nexport const InlineAudioWebWorker = `\nconst DEFAULT_BIT_DEPTH = 32\nconst DEFAULT_SAMPLE_RATE = 44100\n\nclass RecorderProcessor extends AudioWorkletProcessor {\n    constructor() {\n        super()\n        this.currentChunk = [] // Float32Array\n        this.samplesSinceLastExport = 0\n        this.recordSampleRate = DEFAULT_SAMPLE_RATE\n        this.exportSampleRate = DEFAULT_SAMPLE_RATE\n        this.recordBitDepth = DEFAULT_BIT_DEPTH\n        this.exportBitDepth = DEFAULT_BIT_DEPTH\n        this.numberOfChannels = 1\n        this.isRecording = true\n        this.port.onmessage = this.handleMessage.bind(this)\n        this.enableLogging = false\n        this.exportIntervalSamples = 0\n        this.currentPosition = 0 // Track current position in seconds\n    }\n\n    handleMessage(event) {\n        switch (event.data.command) {\n            case 'init':\n                this.enableLogging = event.data.enableLogging || false\n                this.recordSampleRate = event.data.recordSampleRate\n                this.exportSampleRate =\n                    event.data.exportSampleRate || event.data.recordSampleRate\n                this.exportIntervalSamples =\n                    this.recordSampleRate * (event.data.interval / 1000)\n                if (event.data.numberOfChannels) {\n                    this.numberOfChannels = event.data.numberOfChannels\n                }\n                if (event.data.recordBitDepth) {\n                    this.recordBitDepth = event.data.recordBitDepth\n                }\n                this.exportBitDepth =\n                    event.data.exportBitDepth || this.recordBitDepth\n                \n                // Handle position parameter for device switching\n                if (typeof event.data.position === 'number' && event.data.position > 0) {\n                    this.currentPosition = event.data.position\n                    if (this.enableLogging) {\n                        console.log('AudioWorklet initialized with position:', this.currentPosition)\n                    }\n                }\n                break\n\n            case 'stop':\n                this.isRecording = false\n                if (this.currentChunk.length > 0) {\n                    this.processChunk()\n                }\n                break\n                \n            case 'pause':\n                // Just a placeholder for pause handling\n                break\n                \n            case 'resume':\n                // Just a placeholder for resume handling\n                break\n        }\n    }\n\n    process(inputs, _outputs, _parameters) {\n        if (!this.isRecording) return true\n        const input = inputs[0]\n        if (input.length > 0) {\n            const newBuffer = new Float32Array(input[0])\n            this.currentChunk.push(newBuffer)\n            this.samplesSinceLastExport += newBuffer.length\n\n            if (this.samplesSinceLastExport >= this.exportIntervalSamples) {\n                this.processChunk()\n                this.samplesSinceLastExport = 0\n            }\n        }\n        return true\n    }\n\n    mergeBuffers(bufferArray, recLength) {\n        const result = new Float32Array(recLength)\n        let offset = 0\n        for (let i = 0; i < bufferArray.length; i++) {\n            result.set(bufferArray[i], offset)\n            offset += bufferArray[i].length\n        }\n        return result\n    }\n\n    // Keep basic resampling for sample rate conversion\n    resample(samples, targetSampleRate) {\n        if (this.recordSampleRate === targetSampleRate) {\n            return samples\n        }\n        const resampledBuffer = new Float32Array(\n            Math.ceil(\n                (samples.length * targetSampleRate) / this.recordSampleRate\n            )\n        )\n        const ratio = this.recordSampleRate / targetSampleRate\n        let offset = 0\n        for (let i = 0; i < resampledBuffer.length; i++) {\n            const nextOffset = Math.floor((i + 1) * ratio)\n            let accum = 0\n            let count = 0\n            for (let j = offset; j < nextOffset && j < samples.length; j++) {\n                accum += samples[j]\n                count++\n            }\n            resampledBuffer[i] = count > 0 ? accum / count : 0\n            offset = nextOffset\n        }\n        return resampledBuffer\n    }\n\n    // Keep bit depth conversion if needed\n    convertBitDepth(input, targetBitDepth) {\n        if (targetBitDepth === 32) {\n            const output = new Int32Array(input.length)\n            for (let i = 0; i < input.length; i++) {\n                const s = Math.max(-1, Math.min(1, input[i]))\n                output[i] = s < 0 ? s * 0x80000000 : s * 0x7fffffff\n            }\n            return output\n        } else if (targetBitDepth === 16) {\n            const output = new Int16Array(input.length)\n            for (let i = 0; i < input.length; i++) {\n                const s = Math.max(-1, Math.min(1, input[i]))\n                output[i] = s < 0 ? s * 0x8000 : s * 0x7fff\n            }\n            return output\n        }\n        return input\n    }\n\n    processChunk() {\n        if (this.currentChunk.length === 0) return\n\n        // Merge buffers\n        const chunkLength = this.currentChunk.reduce(\n            (acc, buf) => acc + buf.length,\n            0\n        )\n        const mergedChunk = this.mergeBuffers(this.currentChunk, chunkLength)\n\n        // Resample if needed\n        const resampledChunk = this.resample(mergedChunk, this.exportSampleRate)\n\n        // Convert bit depth if needed\n        const finalBuffer =\n            this.recordBitDepth !== this.exportBitDepth\n                ? this.convertBitDepth(resampledChunk, this.exportBitDepth)\n                : resampledChunk\n\n        // Calculate the duration in seconds\n        const chunkDuration = finalBuffer.length / this.exportSampleRate\n        \n        // Send processed chunk with the current position\n        this.port.postMessage({\n            command: 'newData',\n            recordedData: finalBuffer,\n            sampleRate: this.exportSampleRate,\n            bitDepth: this.exportBitDepth,\n            numberOfChannels: this.numberOfChannels,\n            position: this.currentPosition,\n        })\n        \n        // Update the position\n        this.currentPosition += chunkDuration\n\n        // Clear the current chunk\n        this.currentChunk = []\n    }\n}\n\nregisterProcessor('recorder-processor', RecorderProcessor)\n`\n"]}