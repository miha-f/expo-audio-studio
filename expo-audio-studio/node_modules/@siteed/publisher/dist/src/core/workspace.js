"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkspaceService = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const promises_2 = require("node:fs/promises");
const node_path_1 = __importDefault(require("node:path"));
const package_config_template_1 = require("../templates/package-config.template");
const config_1 = require("./config");
const logger_1 = require("../utils/logger");
const find_monorepo_root_1 = require("../utils/find-monorepo-root");
const globby_1 = __importDefault(require("globby"));
class WorkspaceService {
    logger;
    packageCache = new Map();
    rootDir;
    configPromise;
    constructor(config, logger = new logger_1.Logger()) {
        this.logger = logger;
        this.configPromise = config ? Promise.resolve(config) : (0, config_1.loadConfig)();
    }
    getRootDir() {
        if (!this.rootDir) {
            this.rootDir = (0, find_monorepo_root_1.findMonorepoRootSync)(process.cwd());
            this.logger.debug("Monorepo root directory:", this.rootDir);
        }
        return this.rootDir;
    }
    async getPackages(packageNames) {
        const rootDir = this.getRootDir();
        const workspaceGlobs = await this.getWorkspaceGlobs();
        this.logger.debug("Current directory:", process.cwd());
        this.logger.debug("Using workspace globs:", workspaceGlobs);
        const packagePaths = await (0, globby_1.default)(workspaceGlobs, {
            onlyDirectories: true,
            ignore: ["**/node_modules/**"],
            cwd: rootDir,
        });
        this.logger.debug("Found package paths:", packagePaths);
        const contexts = await Promise.all(packagePaths.map(async (packagePath) => {
            try {
                const pkgJson = await this.readPackageJson(packagePath);
                if (!pkgJson.name) {
                    this.logger.debug(`Package at ${packagePath} has no name, skipping`);
                    return null;
                }
                if (packageNames &&
                    !this.matchPackageName(pkgJson.name, packageNames)) {
                    this.logger.debug(`Package ${pkgJson.name} doesn't match requested names:`, packageNames);
                    return null;
                }
                const dependencies = this.ensureStringRecord(pkgJson.dependencies);
                const devDependencies = this.ensureStringRecord(pkgJson.devDependencies);
                const peerDependencies = this.ensureStringRecord(pkgJson.peerDependencies);
                const context = {
                    name: pkgJson.name,
                    path: node_path_1.default.resolve(rootDir, packagePath),
                    currentVersion: pkgJson.version ?? "0.0.0",
                    dependencies,
                    devDependencies,
                    peerDependencies,
                };
                this.packageCache.set(pkgJson.name, context);
                this.logger.debug(`Found valid package: ${pkgJson.name} at ${context.path}`);
                return context;
            }
            catch (error) {
                if (error.code === "ENOENT") {
                    // Package.json doesn't exist, log as debug and skip
                    this.logger.debug(`No package.json found at ${packagePath}, skipping`);
                    return null;
                }
                // Log other errors as debug since they're not critical
                this.logger.debug(`Skipping package at ${packagePath}:`, error);
                return null;
            }
        }));
        const filtered = contexts.filter((ctx) => ctx !== null);
        this.logger.debug(`Total valid packages found: ${filtered.length}`);
        return filtered;
    }
    matchPackageName(packageName, requestedNames) {
        return requestedNames.some((requested) => {
            // Full match
            if (packageName === requested)
                return true;
            // Match simple name against the last part of the package name
            const simpleName = packageName.split("/").pop();
            if (simpleName === requested)
                return true;
            // Match without @ prefix
            if (packageName.startsWith("@") && packageName.slice(1) === requested)
                return true;
            return false;
        });
    }
    async getChangedPackages() {
        const execa = (await Promise.resolve().then(() => __importStar(require("execa")))).default;
        const result = await execa("git", [
            "diff",
            "--name-only",
            "HEAD^",
        ]);
        const changedFiles = result.stdout.split("\n").filter(Boolean);
        const rootDir = this.getRootDir();
        const packages = await this.getPackages();
        return packages.filter((pkg) => changedFiles.some((file) => file.startsWith(node_path_1.default.relative(rootDir, pkg.path))));
    }
    async getPackageConfig(packageName) {
        const packagePath = this.packageCache.get(packageName)?.path;
        if (!packagePath) {
            throw new Error(`Package ${packageName} not found in workspace`);
        }
        const config = await this.configPromise;
        // If no config exists at all, generate a default one
        if (!config || Object.keys(config).length === 0) {
            const pkgJson = await this.readPackageJson(packagePath);
            return (0, package_config_template_1.generateDefaultConfig)({
                packageJson: {
                    name: pkgJson.name ?? packageName,
                    version: pkgJson.version,
                },
                packageManager: "yarn",
                conventionalCommits: true,
                changelogFormat: "conventional",
                versionStrategy: "independent",
                bumpStrategy: "prompt",
                npm: {
                    publish: true,
                    access: "public",
                },
            });
        }
        // Use package-specific config if available, otherwise use monorepo config
        return {
            npm: {
                tag: config.packages?.[packageName]?.npm?.tag ??
                    config.npm?.tag ??
                    "latest",
                publish: config.packages?.[packageName]?.npm?.publish ??
                    config.npm?.publish ??
                    true,
                registry: config.packages?.[packageName]?.npm?.registry ??
                    config.npm?.registry ??
                    "https://registry.npmjs.org/",
                access: config.packages?.[packageName]?.npm?.access ??
                    config.npm?.access ??
                    "public",
                otp: config.packages?.[packageName]?.npm?.otp ?? config.npm?.otp,
            },
            packageManager: config.packages?.[packageName]?.packageManager ??
                config.packageManager ??
                "yarn",
            changelogFile: config.packages?.[packageName]?.changelogFile ??
                config.changelogFile ??
                "CHANGELOG.md",
            conventionalCommits: config.packages?.[packageName]?.conventionalCommits ??
                config.conventionalCommits ??
                true,
            changelogFormat: config.packages?.[packageName]?.changelogFormat ??
                config.changelogFormat ??
                "conventional",
            versionStrategy: config.packages?.[packageName]?.versionStrategy ??
                config.versionStrategy ??
                "independent",
            bumpStrategy: config.packages?.[packageName]?.bumpStrategy ??
                config.bumpStrategy ??
                "prompt",
            preReleaseId: config.packages?.[packageName]?.preReleaseId ?? config.preReleaseId,
            updateDependenciesOnRelease: config.packages?.[packageName]?.updateDependenciesOnRelease ??
                config.updateDependenciesOnRelease ??
                false,
            dependencyUpdateStrategy: config.packages?.[packageName]?.dependencyUpdateStrategy ??
                config.dependencyUpdateStrategy ??
                "none",
            git: {
                tagPrefix: config.packages?.[packageName]?.git?.tagPrefix ??
                    config.git?.tagPrefix ??
                    `${packageName}@`,
                requireUpstreamTracking: config.packages?.[packageName]?.git?.requireUpstreamTracking ??
                    config.git?.requireUpstreamTracking ??
                    true,
                requireCleanWorkingDirectory: config.packages?.[packageName]?.git?.requireCleanWorkingDirectory ??
                    config.git?.requireCleanWorkingDirectory ??
                    true,
                requireUpToDate: config.packages?.[packageName]?.git?.requireUpToDate ??
                    config.git?.requireUpToDate ??
                    true,
                commit: config.packages?.[packageName]?.git?.commit ??
                    config.git?.commit ??
                    true,
                push: config.packages?.[packageName]?.git?.push ?? config.git?.push ?? true,
                commitMessage: config.packages?.[packageName]?.git?.commitMessage ??
                    config.git?.commitMessage ??
                    `chore(release): release ${packageName}@\${version}`,
                tag: config.packages?.[packageName]?.git?.tag ?? config.git?.tag ?? true,
                tagMessage: config.packages?.[packageName]?.git?.tagMessage ??
                    config.git?.tagMessage,
                allowedBranches: config.packages?.[packageName]?.git?.allowedBranches ??
                    config.git?.allowedBranches ?? ["main", "master"],
                remote: config.packages?.[packageName]?.git?.remote ??
                    config.git?.remote ??
                    "origin",
            },
            hooks: {
                ...config.hooks,
                ...config.packages?.[packageName]?.hooks,
            },
            packValidation: {
                enabled: config.packages?.[packageName]?.packValidation?.enabled ??
                    config.packValidation?.enabled ??
                    true,
                validateFiles: config.packages?.[packageName]?.packValidation?.validateFiles ??
                    config.packValidation?.validateFiles ??
                    true,
                validateBuildArtifacts: config.packages?.[packageName]?.packValidation
                    ?.validateBuildArtifacts ??
                    config.packValidation?.validateBuildArtifacts ??
                    true,
                requiredFiles: config.packages?.[packageName]?.packValidation?.requiredFiles ??
                    config.packValidation?.requiredFiles,
            },
        };
    }
    async readPackageJson(packagePath) {
        const rootDir = this.getRootDir();
        const fullPath = node_path_1.default.resolve(rootDir, packagePath, "package.json");
        const content = await (0, promises_2.readFile)(fullPath, "utf-8");
        const parsed = JSON.parse(content);
        this.logger.debug(`Successfully read package.json at: ${fullPath}`);
        return parsed;
    }
    async getWorkspaceGlobs() {
        try {
            const rootDir = this.getRootDir();
            const rootPkgJsonPath = node_path_1.default.join(rootDir, "package.json");
            const content = await (0, promises_2.readFile)(rootPkgJsonPath, "utf-8");
            const rootPkgJson = JSON.parse(content);
            this.logger.debug("Root package.json workspaces:", rootPkgJson.workspaces);
            if (rootPkgJson.workspaces) {
                if (Array.isArray(rootPkgJson.workspaces)) {
                    return rootPkgJson.workspaces;
                }
                if (rootPkgJson.workspaces.packages &&
                    Array.isArray(rootPkgJson.workspaces.packages)) {
                    return rootPkgJson.workspaces.packages;
                }
            }
            this.logger.warning("No workspaces found in package.json, using default: packages/*");
            return ["packages/*"];
        }
        catch (error) {
            this.logger.error("Error reading root package.json:", error);
            return ["packages/*"];
        }
    }
    ensureStringRecord(obj) {
        if (!obj)
            return {};
        return Object.entries(obj).reduce((acc, [key, value]) => {
            if (typeof value === "string") {
                acc[key] = value;
            }
            return acc;
        }, {});
    }
    // Adjusted formatting per Prettier
    async writePackageJson(packagePath, data) {
        const rootDir = this.getRootDir();
        const fullPath = node_path_1.default.resolve(rootDir, packagePath, "package.json");
        try {
            const content = JSON.stringify(data, null, 2);
            await promises_1.default.writeFile(fullPath, content, "utf8");
            this.logger.debug(`Successfully wrote package.json at: ${fullPath}`);
        }
        catch (error) {
            this.logger.error(`Failed to write package.json at: ${fullPath}`, error);
            throw error;
        }
    }
    async getCurrentPackage() {
        const currentDir = node_path_1.default.resolve(process.cwd());
        const packages = await this.getPackages();
        // Find package whose path matches the current directory
        const currentPackage = packages.find((pkg) => currentDir.startsWith(pkg.path));
        return currentPackage || null;
    }
}
exports.WorkspaceService = WorkspaceService;
