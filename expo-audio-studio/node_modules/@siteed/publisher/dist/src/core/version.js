"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersionService = void 0;
const execa_1 = __importDefault(require("execa"));
const semver = __importStar(require("semver"));
const git_1 = require("./git");
const fs = __importStar(require("fs"));
class VersionService {
    git;
    constructor(gitConfig) {
        const rootDir = process.cwd(); // Or get it from workspace service
        this.git = new git_1.GitService(gitConfig, rootDir);
    }
    async execCommand(command, args, options) {
        return (0, execa_1.default)(command, args, options);
    }
    async bump(context, config) {
        const packageManager = config.packageManager || "yarn";
        try {
            if (!context.newVersion) {
                throw new Error("New version is not defined");
            }
            await this.execCommand(packageManager, ["version", context.newVersion], {
                cwd: context.path,
            });
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : "Unknown error";
            throw new Error(`Failed to bump version: ${errorMessage}`);
        }
    }
    determineVersion(context, bumpType, preReleaseId) {
        const { currentVersion } = context;
        if (bumpType === "custom") {
            if (!context.newVersion) {
                throw new Error("New version is required for custom bump type");
            }
            return context.newVersion;
        }
        if (!semver.valid(currentVersion)) {
            throw new Error(`Invalid current version: ${currentVersion}`);
        }
        let newVersion;
        if (bumpType.startsWith("pre")) {
            if (!preReleaseId) {
                throw new Error("Prerelease identifier is required for prerelease versions");
            }
            newVersion = semver.inc(currentVersion, bumpType, preReleaseId);
        }
        else {
            newVersion = semver.inc(currentVersion, bumpType);
        }
        if (!newVersion) {
            throw new Error(`Failed to increment version ${currentVersion} with bump type ${bumpType}`);
        }
        return newVersion;
    }
    async updateDependencies(context, updatedPackages) {
        const packageJsonPath = `${context.path}/package.json`;
        const packageJson = JSON.parse(await fs.promises.readFile(packageJsonPath, "utf8"));
        let updated = false;
        for (const [name, version] of updatedPackages.entries()) {
            if (packageJson.dependencies?.[name]) {
                packageJson.dependencies[name] = `^${version}`;
                updated = true;
            }
            if (packageJson.devDependencies?.[name]) {
                packageJson.devDependencies[name] = `^${version}`;
                updated = true;
            }
            if (packageJson.peerDependencies?.[name]) {
                packageJson.peerDependencies[name] = `^${version}`;
                updated = true;
            }
        }
        if (updated) {
            await fs.promises.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2) + "\n");
            await this.execCommand("yarn", ["up", ...Array.from(updatedPackages.keys())], {
                cwd: context.path,
            });
        }
    }
    async analyzeCommits(context) {
        try {
            const lastTag = await this.git.getLastTag(context.name);
            const commits = await this.git.getCommitsSinceTag(lastTag, {
                packageName: context.name,
                packagePath: context.path,
                filterByPath: true,
            });
            if (commits.some((commit) => commit.message.includes("BREAKING CHANGE"))) {
                return "major";
            }
            if (commits.some((commit) => commit.message.startsWith("feat"))) {
                return "minor";
            }
            return "patch";
        }
        catch {
            return "patch";
        }
    }
    validateVersion(version) {
        // Basic semver validation
        if (!semver.valid(version)) {
            throw new Error(`Invalid version format: ${version}\n` +
                "Version must follow semver format (major.minor.patch[-prerelease][+build])");
        }
        // Additional validations
        const parsed = semver.parse(version);
        if (!parsed) {
            throw new Error(`Failed to parse version: ${version}`);
        }
        // Validate version components
        if (parsed.major < 0 || parsed.minor < 0 || parsed.patch < 0) {
            throw new Error("Version components cannot be negative");
        }
        // Validate prerelease format if present
        if (parsed.prerelease.length > 0) {
            const prereleaseId = parsed.prerelease[0];
            if (typeof prereleaseId === "string" &&
                !prereleaseId.match(/^[a-zA-Z][\w.-]*$/)) {
                throw new Error("Invalid prerelease identifier format. Must start with a letter and contain only alphanumeric characters, dots, and hyphens.");
            }
        }
        // Validate build metadata format if present
        if (parsed.build.length > 0) {
            const buildId = parsed.build[0];
            if (!buildId.match(/^[\w.-]+$/)) {
                throw new Error("Invalid build metadata format. Must contain only alphanumeric characters, dots, and hyphens.");
            }
        }
    }
}
exports.VersionService = VersionService;
