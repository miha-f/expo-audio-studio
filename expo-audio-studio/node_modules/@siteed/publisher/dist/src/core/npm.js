"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NpmService = void 0;
const execa_1 = __importDefault(require("execa"));
const logger_1 = require("../utils/logger");
class NpmService {
    config;
    logger;
    constructor(config, logger) {
        this.config = config;
        this.logger = logger ?? new logger_1.Logger();
    }
    getEffectiveConfig(providedConfig) {
        return providedConfig?.npm ?? this.config;
    }
    async validateAuth(config) {
        const effectiveConfig = this.getEffectiveConfig(config);
        try {
            const execa = (await Promise.resolve().then(() => __importStar(require("execa")))).default;
            const result = await execa("npm", [
                "whoami",
                "--registry",
                effectiveConfig.registry,
            ]);
            const output = result.stdout.toString().trim();
            if (!output) {
                throw new Error("Not authenticated to npm registry");
            }
        }
        catch (error) {
            if (error instanceof Error) {
                throw new Error(`npm authentication failed: ${error.message}`);
            }
            throw new Error("npm authentication failed: Unknown error occurred");
        }
    }
    async publish(context, config) {
        const effectiveConfig = this.getEffectiveConfig(config);
        const publishArgs = [
            "publish",
            "--registry",
            effectiveConfig.registry,
            "--tag",
            effectiveConfig.tag,
            "--access",
            effectiveConfig.access,
        ];
        if (effectiveConfig.otp) {
            publishArgs.push("--otp", effectiveConfig.otp);
        }
        try {
            const execa = (await Promise.resolve().then(() => __importStar(require("execa")))).default;
            await execa("npm", publishArgs, { cwd: context.path });
            return {
                published: true,
                registry: effectiveConfig.registry,
            };
        }
        catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to publish package: ${error.message}`);
            }
            throw new Error("Failed to publish package: Unknown error occurred");
        }
    }
    async getLatestVersion(packageName, config) {
        const effectiveConfig = this.getEffectiveConfig(config);
        try {
            const execa = (await Promise.resolve().then(() => __importStar(require("execa")))).default;
            const result = await execa("npm", [
                "view",
                packageName,
                "version",
                "--registry",
                effectiveConfig.registry,
            ]);
            return result.stdout.toString().trim();
        }
        catch (error) {
            this.logger.debug("Failed to get latest version", {
                error: error instanceof Error ? error.message : "Unknown error",
            });
            return "0.0.0";
        }
    }
    async checkWorkspaceIntegrity() {
        try {
            this.logger.debug("Checking npm workspace integrity...");
            const startTime = performance.now();
            // Use --dry-run and --package-lock-only for faster checks
            await (0, execa_1.default)("npm", ["install", "--dry-run", "--package-lock-only"]);
            const duration = ((performance.now() - startTime) / 1000).toFixed(2);
            this.logger.debug(`npm integrity check completed in ${duration}s`);
            return true;
        }
        catch (error) {
            this.logger.debug("npm integrity check failed", {
                error: error instanceof Error ? error.message : "Unknown error",
            });
            return false;
        }
    }
    async updateDependencies(context, dependencies) {
        try {
            const execa = (await Promise.resolve().then(() => __importStar(require("execa")))).default;
            await execa("npm", ["install", ...dependencies], {
                cwd: context.path,
            });
        }
        catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to update dependencies: ${error.message}`);
            }
            throw new Error("Failed to update dependencies: Unknown error occurred");
        }
    }
    async pack(context) {
        let packageFile = "";
        try {
            const execa = (await Promise.resolve().then(() => __importStar(require("execa")))).default;
            const fs = await Promise.resolve().then(() => __importStar(require("fs/promises")));
            const path = await Promise.resolve().then(() => __importStar(require("path")));
            const tar = await Promise.resolve().then(() => __importStar(require("tar")));
            const crypto = await Promise.resolve().then(() => __importStar(require("crypto")));
            this.logger.debug("Starting package pack process", {
                package: context.name,
                path: context.path,
            });
            // Pack the package
            const result = await execa("npm", ["pack", "--json"], {
                cwd: context.path,
            });
            packageFile = result.stdout.toString().trim();
            const packagePath = path.join(context.path, packageFile);
            this.logger.debug("Package created", {
                filename: packageFile,
                path: packagePath,
            });
            // Get compressed size
            const stats = await fs.stat(packagePath);
            // Calculate SHA hash
            const fileBuffer = await fs.readFile(packagePath);
            const hashSum = crypto.createHash("sha256");
            hashSum.update(fileBuffer);
            const sha = hashSum.digest("hex");
            // Get uncompressed size and file list
            const files = [];
            let uncompressedSize = 0;
            await tar.list({
                file: packagePath,
                onentry: (entry) => {
                    if (entry.type === "File") {
                        files.push({
                            path: entry.path,
                            size: entry.size,
                        });
                        uncompressedSize += entry.size;
                    }
                },
            });
            const archiveInfo = {
                filename: packageFile,
                path: packagePath,
                size: {
                    compressed: stats.size,
                    uncompressed: uncompressedSize,
                },
                files,
                created: new Date(),
                sha,
            };
            this.logger.debug("Package analysis complete", {
                compressedSize: `${(stats.size / 1024).toFixed(2)}KB`,
                uncompressedSize: `${(uncompressedSize / 1024).toFixed(2)}KB`,
                fileCount: files.length,
            });
            return archiveInfo;
        }
        catch (error) {
            this.logger.error("Package pack failed", {
                error: error instanceof Error ? error.message : "Unknown error",
                package: context.name,
            });
            throw error;
        }
        finally {
            if (packageFile) {
                try {
                    const fs = await Promise.resolve().then(() => __importStar(require("fs/promises")));
                    const path = await Promise.resolve().then(() => __importStar(require("path")));
                    const filePath = path.join(context.path, packageFile);
                    await fs.unlink(filePath);
                    this.logger.debug("Cleaned up package file", { path: filePath });
                }
                catch (cleanupError) {
                    this.logger.warn("Failed to cleanup package file", {
                        error: cleanupError instanceof Error
                            ? cleanupError.message
                            : "Unknown error",
                        path: packageFile,
                    });
                }
            }
        }
    }
    async runScript(context, script) {
        try {
            const execa = (await Promise.resolve().then(() => __importStar(require("execa")))).default;
            this.logger.debug("Running npm script", {
                script,
                cwd: context.path,
            });
            await execa("npm", ["run", script], {
                cwd: context.path,
            });
            this.logger.debug("Script completed successfully", { script });
        }
        catch (error) {
            this.logger.error("Script execution failed", {
                script,
                error: error instanceof Error ? error.message : "Unknown error",
            });
            throw new Error(`Failed to run script ${script}: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    async install() {
        try {
            const execa = (await Promise.resolve().then(() => __importStar(require("execa")))).default;
            this.logger.debug("Starting npm install");
            await execa("npm", ["install"]);
            this.logger.debug("Dependencies installed successfully");
        }
        catch (error) {
            this.logger.error("Installation failed", {
                error: error instanceof Error ? error.message : "Unknown error",
            });
            throw new Error(`Failed to install dependencies: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    parseJsonResponse(stdout) {
        try {
            return JSON.parse(stdout);
        }
        catch {
            return {};
        }
    }
    async getDependencyUpdates() {
        try {
            const result = await (0, execa_1.default)("npm", ["outdated", "--json"]);
            const outdated = this.parseJsonResponse(result.stdout);
            const updates = [];
            for (const [name, info] of Object.entries(outdated)) {
                updates.push({
                    name,
                    currentVersion: info.current,
                    latestVersion: info.latest,
                    type: info.type,
                    isWorkspaceDependency: name.startsWith("@siteed/") || name.startsWith("@your-scope/"),
                    updateAvailable: info.current !== info.latest,
                });
            }
            return updates;
        }
        catch (error) {
            this.logger.debug("Failed to check for dependency updates", {
                error: error instanceof Error ? error.message : "Unknown error",
            });
            return [];
        }
    }
}
exports.NpmService = NpmService;
