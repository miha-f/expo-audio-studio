"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InitService = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const inquirer_1 = __importDefault(require("inquirer"));
const path_1 = __importDefault(require("path"));
const templates_1 = require("../templates");
const detect_package_manager_1 = require("../utils/detect-package-manager");
const workspace_1 = require("./workspace");
class InitService {
    logger;
    workspaceService;
    packageManager;
    constructor(logger, workspaceService = new workspace_1.WorkspaceService()) {
        this.logger = logger;
        this.workspaceService = workspaceService;
        this.packageManager = (0, detect_package_manager_1.detectPackageManager)(process.cwd());
    }
    async initialize({ packages, options = {}, }) {
        try {
            let packageOptions;
            let monorepoOptions;
            if (options.interactive) {
                const isRoot = process.cwd() === this.workspaceService.getRootDir();
                if (isRoot) {
                    monorepoOptions = await this.promptForMonorepoOptions();
                    // Use monorepo answers as defaults for package options
                    packageOptions = {
                        ...monorepoOptions,
                        changelogFile: "CHANGELOG.md",
                    };
                }
                else {
                    packageOptions = await this.promptForPackageOptions();
                }
            }
            // Get packages to initialize
            const packagesToInit = packages.length > 0
                ? await this.workspaceService.getPackages(packages)
                : await this.workspaceService.getPackages();
            if (packagesToInit.length === 0) {
                throw new Error("No packages found to initialize");
            }
            // Initialize each package
            for (const pkg of packagesToInit) {
                this.logger.info(`\nInitializing ${pkg.name}...`);
                // Create directory structure
                await this.createDirectoryStructure({ packagePath: pkg.path });
                // Initialize package files
                await this.initializePackageFiles({
                    packagePath: pkg.path,
                    force: options.force,
                    options: packageOptions,
                    format: options.format,
                });
                this.logger.success(`Initialized ${pkg.name}`);
            }
            // Create root config if it doesn't exist
            await this.initializeRootConfig({
                force: options.force,
                options: monorepoOptions,
                format: options.format,
            });
            this.logger.success("\nInitialization completed successfully!");
            this.logger.info("\nNext steps:");
            this.logger.info("1. Review and adjust the generated configurations");
            this.logger.info("2. Update CHANGELOG.md files with your initial content");
            this.logger.info("3. Review and customize release hooks in hooks.ts");
            this.logger.info("4. Commit the changes");
        }
        catch (error) {
            this.logger.error("Initialization failed:", error);
            throw error;
        }
    }
    async promptForPackageOptions() {
        const answers = await inquirer_1.default.prompt([
            {
                type: "confirm",
                name: "conventionalCommits",
                message: "Use conventional commits?",
                default: true,
            },
            {
                type: "list",
                name: "changelogFormat",
                message: "Choose changelog format:",
                choices: [
                    { name: "Conventional Changelog", value: "conventional" },
                    { name: "Keep a Changelog", value: "keep-a-changelog" },
                ],
                default: "conventional",
            },
            {
                type: "list",
                name: "versionStrategy",
                message: "Choose version strategy:",
                choices: ["independent", "fixed"],
                default: "independent",
            },
            {
                type: "list",
                name: "bumpStrategy",
                message: "Choose bump strategy:",
                choices: ["conventional", "prompt", "auto"],
                default: "prompt",
            },
            {
                type: "confirm",
                name: "npmPublish",
                message: "Publish to npm?",
                default: true,
            },
            {
                type: "list",
                name: "npmAccess",
                message: "npm package access:",
                choices: ["public", "restricted"],
                default: "public",
                when: (answers) => answers.npmPublish,
            },
            {
                type: "input",
                name: "changelogFile",
                message: "Changelog file path:",
                default: "CHANGELOG.md",
            },
        ]);
        return {
            ...answers,
            packageManager: this.packageManager,
        };
    }
    async promptForMonorepoOptions() {
        const baseAnswers = await inquirer_1.default.prompt([
            {
                type: "confirm",
                name: "conventionalCommits",
                message: "Use conventional commits?",
                default: true,
            },
            {
                type: "list",
                name: "changelogFormat",
                message: "Choose changelog format:",
                choices: [
                    { name: "Conventional Changelog", value: "conventional" },
                    { name: "Keep a Changelog", value: "keep-a-changelog" },
                ],
                default: "conventional",
            },
            {
                type: "list",
                name: "versionStrategy",
                message: "Choose version strategy:",
                choices: ["independent", "fixed"],
                default: "independent",
            },
            {
                type: "list",
                name: "bumpStrategy",
                message: "Choose bump strategy:",
                choices: ["conventional", "prompt", "auto"],
                default: "prompt",
            },
            {
                type: "confirm",
                name: "npmPublish",
                message: "Publish to npm?",
                default: true,
            },
            {
                type: "list",
                name: "npmAccess",
                message: "npm package access:",
                choices: ["public", "restricted"],
                default: "public",
                when: (answers) => answers.npmPublish,
            },
        ]);
        const monorepoSpecific = await inquirer_1.default.prompt([
            {
                type: "input",
                name: "packagesGlob",
                message: "Packages glob pattern:",
                default: "packages/*",
            },
            {
                type: "number",
                name: "maxConcurrency",
                message: "Maximum concurrent package operations:",
                default: 4,
            },
            {
                type: "input",
                name: "ignorePackages",
                message: "Packages to ignore (comma-separated):",
                default: "",
                filter: (input) => input ? input.split(",").map((p) => p.trim()) : [],
            },
        ]);
        return {
            ...baseAnswers,
            ...monorepoSpecific,
            packageManager: this.packageManager,
        };
    }
    async validateNoExistingConfig(packagePath) {
        const possibleConfigs = [
            path_1.default.join(packagePath, "publisher.config.json"),
            path_1.default.join(packagePath, "publisher.config.ts"),
        ];
        for (const configPath of possibleConfigs) {
            try {
                await promises_1.default.access(configPath);
                throw new Error(`Configuration already exists at ${configPath}. Use --force to overwrite.`);
            }
            catch (error) {
                // File doesn't exist, continue checking
                if (error.code !== "ENOENT") {
                    throw error;
                }
            }
        }
    }
    async initializePackageFiles({ packagePath, force = false, options, format = "json", }) {
        const rootDir = this.workspaceService.getRootDir();
        const absolutePackagePath = path_1.default.isAbsolute(packagePath)
            ? packagePath
            : path_1.default.join(rootDir, packagePath);
        // Add validation before proceeding
        if (!force) {
            await this.validateNoExistingConfig(absolutePackagePath);
        }
        // Ensure directory structure exists
        await this.createDirectoryStructure({ packagePath: absolutePackagePath });
        const packageJsonPath = path_1.default.join(absolutePackagePath, "package.json");
        const packageJson = await promises_1.default
            .readFile(packageJsonPath, "utf-8")
            .then((content) => JSON.parse(content))
            .catch(() => {
            throw new Error(`Could not read package.json in ${absolutePackagePath}`);
        });
        this.logger.debug(`Creating files in: ${absolutePackagePath}`);
        // Ensure all parent directories exist for each file
        const configExtension = format === "json" ? "json" : "ts";
        for (const file of [
            {
                path: path_1.default.join(absolutePackagePath, `publisher.config.${configExtension}`),
                content: (0, templates_1.generatePackageConfig)({
                    options: {
                        packageJson,
                        packageManager: this.packageManager,
                        conventionalCommits: options?.conventionalCommits,
                        changelogFormat: options?.changelogFormat,
                        versionStrategy: options?.versionStrategy,
                        bumpStrategy: options?.bumpStrategy,
                        npm: options
                            ? {
                                publish: options.npmPublish,
                                access: options.npmAccess,
                            }
                            : undefined,
                    },
                    format,
                }),
                description: "package configuration",
            },
            {
                path: path_1.default.join(absolutePackagePath, "CHANGELOG.md"),
                content: (0, templates_1.getChangelogTemplate)(options?.changelogFormat ?? "conventional"),
                description: "changelog",
            },
            {
                path: path_1.default.join(absolutePackagePath, ".publisher/hooks/index.ts"),
                content: templates_1.hooksTemplate,
                description: "release hooks",
            },
        ]) {
            try {
                // Ensure parent directory exists
                await promises_1.default.mkdir(path_1.default.dirname(file.path), { recursive: true });
                // Check if file exists
                try {
                    await promises_1.default.access(file.path);
                    if (!force) {
                        this.logger.warning(`${file.description} already exists for ${packagePath}. Use --force to overwrite.`);
                        continue;
                    }
                }
                catch {
                    // File doesn't exist, continue with creation
                }
                await promises_1.default.writeFile(file.path, file.content);
                this.logger.info(`Created ${file.description} for ${packagePath}`);
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                throw new Error(`Failed to create ${file.description}: ${errorMessage}`);
            }
        }
    }
    async initializeRootConfig({ force = false, options, format = "json", }) {
        const rootDir = this.workspaceService.getRootDir();
        const currentDir = process.cwd();
        if (rootDir !== currentDir) {
            this.logger.debug("Skipping root config creation - not in monorepo root");
            return;
        }
        // Add validation before proceeding
        if (!force) {
            await this.validateNoExistingConfig(rootDir);
        }
        const packageManager = options?.packageManager ?? this.packageManager;
        const packageJsonPath = path_1.default.join(rootDir, "package.json");
        const packageJson = await promises_1.default
            .readFile(packageJsonPath, "utf-8")
            .then((content) => JSON.parse(content))
            .catch(() => {
            throw new Error("Could not read package.json for root config");
        });
        const configExtension = format === "json" ? "json" : "ts";
        const rootConfigPath = path_1.default.join(rootDir, `publisher.config.${configExtension}`);
        const content = (0, templates_1.generateMonorepoConfig)({
            options: {
                packageJson,
                packageManager,
                conventionalCommits: options?.conventionalCommits,
                versionStrategy: options?.versionStrategy,
                bumpStrategy: options?.bumpStrategy,
                packagesGlob: options?.packagesGlob ?? "packages/*",
                changelogFormat: options?.changelogFormat,
            },
            format,
        });
        await promises_1.default.writeFile(rootConfigPath, content);
        this.logger.success("Created root configuration");
    }
    async createDirectoryStructure({ packagePath, }) {
        const publisherDir = path_1.default.join(packagePath, ".publisher");
        const hooksDir = path_1.default.join(publisherDir, "hooks");
        try {
            // Create directories with recursive option
            await promises_1.default.mkdir(publisherDir, { recursive: true });
            await promises_1.default.mkdir(hooksDir, { recursive: true });
            // Verify directories were created
            const publisherStats = await promises_1.default.stat(publisherDir);
            const hooksStats = await promises_1.default.stat(hooksDir);
            if (!publisherStats.isDirectory() || !hooksStats.isDirectory()) {
                throw new Error("Failed to create directory structure - not a directory");
            }
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            throw new Error(`Failed to create directory structure: ${errorMessage}`, {
                cause: error,
            });
        }
    }
}
exports.InitService = InitService;
